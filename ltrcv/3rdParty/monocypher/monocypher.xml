<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Monocypher</name>
    </assembly>
    <members>
        <member name="T:Monocypher.Monocypher">
            <summary>
            Static class containing all cryptographic functions.
            </summary>
        </member>
        <member name="M:Monocypher.Monocypher.AsByte8(System.Byte[])">
            <summary>
            Returns a 8-byte struct reference from the specified byte array.
            </summary>
            <param name="buffer">A byte array with 8 bytes.</param>
            <returns>A reference to a 8-byte struct mapping to the same array</returns>
        </member>
        <member name="M:Monocypher.Monocypher.AsByte12(System.Byte[])">
            <summary>
            Returns a 12-byte struct reference from the specified byte array.
            </summary>
            <param name="buffer">A byte array with 12 bytes.</param>
            <returns>A reference to a 12-byte struct mapping to the same array</returns>
        </member>
        <member name="M:Monocypher.Monocypher.AsByte16(System.Byte[])">
            <summary>
            Returns a 16-byte struct reference from the specified byte array.
            </summary>
            <param name="buffer">A byte array with 16 bytes.</param>
            <returns>A reference to a 16-byte struct mapping to the same array</returns>
        </member>
        <member name="M:Monocypher.Monocypher.AsByte24(System.Byte[])">
            <summary>
            Returns a 24-byte struct reference from the specified byte array.
            </summary>
            <param name="buffer">A byte array with 24 bytes.</param>
            <returns>A reference to a 24-byte struct mapping to the same array</returns>
        </member>
        <member name="M:Monocypher.Monocypher.AsByte32(System.Byte[])">
            <summary>
            Returns a 32-byte struct reference from the specified byte array.
            </summary>
            <param name="buffer">A byte array with 32 bytes.</param>
            <returns>A reference to a 32-byte struct mapping to the same array</returns>
        </member>
        <member name="M:Monocypher.Monocypher.AsByte64(System.Byte[])">
            <summary>
            Returns a 64-byte struct reference from the specified byte array.
            </summary>
            <param name="buffer">A byte array with 64 bytes.</param>
            <returns>A reference to a 64-byte struct mapping to the same array</returns>
        </member>
        <member name="M:Monocypher.Monocypher.AsByte8(System.Span{System.Byte})">
            <summary>
            Returns a 8-byte struct reference from the specified span.
            </summary>
            <param name="buffer">A span with 8 bytes.</param>
            <returns>A reference to a 8-byte struct mapping from the specified span.</returns>
        </member>
        <member name="M:Monocypher.Monocypher.AsByte12(System.Span{System.Byte})">
            <summary>
            Returns a 12-byte struct reference from the specified span.
            </summary>
            <param name="buffer">A span with 12 bytes.</param>
            <returns>A reference to a 12-byte struct mapping from the specified span.</returns>
        </member>
        <member name="M:Monocypher.Monocypher.AsByte16(System.Span{System.Byte})">
            <summary>
            Returns a 16-byte struct reference from the specified span.
            </summary>
            <param name="buffer">A span with 16 bytes.</param>
            <returns>A reference to a 16-byte struct mapping from the specified span.</returns>
        </member>
        <member name="M:Monocypher.Monocypher.AsByte24(System.Span{System.Byte})">
            <summary>
            Returns a 24-byte struct reference from the specified span.
            </summary>
            <param name="buffer">A span with 24 bytes.</param>
            <returns>A reference to a 24-byte struct mapping from the specified span.</returns>
        </member>
        <member name="M:Monocypher.Monocypher.AsByte32(System.Span{System.Byte})">
            <summary>
            Returns a 32-byte struct reference from the specified span.
            </summary>
            <param name="buffer">A span with 32 bytes.</param>
            <returns>A reference to a 32-byte struct mapping from the specified span.</returns>
        </member>
        <member name="M:Monocypher.Monocypher.AsByte64(System.Span{System.Byte})">
            <summary>
            Returns a 64-byte struct reference from the specified span.
            </summary>
            <param name="buffer">A span with 64 bytes.</param>
            <returns>A reference to a 64-byte struct mapping from the specified span.</returns>
        </member>
        <member name="M:Monocypher.Monocypher.AsByte8(System.ReadOnlySpan{System.Byte})">
            <summary>
            Returns a 8-byte struct reference from the specified span.
            </summary>
            <param name="buffer">A span with 8 bytes.</param>
            <returns>A reference to a 8-byte struct mapping from the specified span.</returns>
        </member>
        <member name="M:Monocypher.Monocypher.AsByte12(System.ReadOnlySpan{System.Byte})">
            <summary>
            Returns a 12-byte struct reference from the specified span.
            </summary>
            <param name="buffer">A span with 12 bytes.</param>
            <returns>A reference to a 12-byte struct mapping from the specified span.</returns>
        </member>
        <member name="M:Monocypher.Monocypher.AsByte16(System.ReadOnlySpan{System.Byte})">
            <summary>
            Returns a 16-byte struct reference from the specified span.
            </summary>
            <param name="buffer">A span with 16 bytes.</param>
            <returns>A reference to a 16-byte struct mapping from the specified span.</returns>
        </member>
        <member name="M:Monocypher.Monocypher.AsByte24(System.ReadOnlySpan{System.Byte})">
            <summary>
            Returns a 24-byte struct reference from the specified span.
            </summary>
            <param name="buffer">A span with 24 bytes.</param>
            <returns>A reference to a 24-byte struct mapping from the specified span.</returns>
        </member>
        <member name="M:Monocypher.Monocypher.AsByte32(System.ReadOnlySpan{System.Byte})">
            <summary>
            Returns a 32-byte struct reference from the specified span.
            </summary>
            <param name="buffer">A span with 32 bytes.</param>
            <returns>A reference to a 32-byte struct mapping from the specified span.</returns>
        </member>
        <member name="M:Monocypher.Monocypher.AsByte64(System.ReadOnlySpan{System.Byte})">
            <summary>
            Returns a 64-byte struct reference from the specified span.
            </summary>
            <param name="buffer">A span with 64 bytes.</param>
            <returns>A reference to a 64-byte struct mapping from the specified span.</returns>
        </member>
        <member name="M:Monocypher.Monocypher.AsSpan(Monocypher.Monocypher.Byte8@)">
            <summary>
            Returns a 8-byte span from the specified struct reference.
            </summary>
            <param name="buffer">A 8-byte struct.</param>
            <returns>A 8-byte span mapping from the specified struct reference.</returns>
        </member>
        <member name="M:Monocypher.Monocypher.AsSpan(Monocypher.Monocypher.Byte12@)">
            <summary>
            Returns a 12-byte span from the specified struct reference.
            </summary>
            <param name="buffer">A 12-byte struct.</param>
            <returns>A 12-byte span mapping from the specified struct reference.</returns>
        </member>
        <member name="M:Monocypher.Monocypher.AsSpan(Monocypher.Monocypher.Byte16@)">
            <summary>
            Returns a 16-byte span from the specified struct reference.
            </summary>
            <param name="buffer">A 16-byte struct.</param>
            <returns>A 16-byte span mapping from the specified struct reference.</returns>
        </member>
        <member name="M:Monocypher.Monocypher.AsSpan(Monocypher.Monocypher.Byte24@)">
            <summary>
            Returns a 24-byte span from the specified struct reference.
            </summary>
            <param name="buffer">A 24-byte struct.</param>
            <returns>A 24-byte span mapping from the specified struct reference.</returns>
        </member>
        <member name="M:Monocypher.Monocypher.AsSpan(Monocypher.Monocypher.Byte32@)">
            <summary>
            Returns a 32-byte span from the specified struct reference.
            </summary>
            <param name="buffer">A 32-byte struct.</param>
            <returns>A 32-byte span mapping from the specified struct reference.</returns>
        </member>
        <member name="M:Monocypher.Monocypher.AsSpan(Monocypher.Monocypher.Byte64@)">
            <summary>
            Returns a 64-byte span from the specified struct reference.
            </summary>
            <param name="buffer">A 64-byte struct.</param>
            <returns>A 64-byte span mapping from the specified struct reference.</returns>
        </member>
        <member name="M:Monocypher.Monocypher.AsReadOnlySpan(Monocypher.Monocypher.Byte8@)">
            <summary>
            Returns a 8-byte span from the specified struct reference.
            </summary>
            <param name="buffer">A 8-byte struct.</param>
            <returns>A 8-byte span mapping from the specified struct reference.</returns>
        </member>
        <member name="M:Monocypher.Monocypher.AsReadOnlySpan(Monocypher.Monocypher.Byte12@)">
            <summary>
            Returns a 12-byte span from the specified struct reference.
            </summary>
            <param name="buffer">A 12-byte struct.</param>
            <returns>A 12-byte span mapping from the specified struct reference.</returns>
        </member>
        <member name="M:Monocypher.Monocypher.AsReadOnlySpan(Monocypher.Monocypher.Byte16@)">
            <summary>
            Returns a 16-byte span from the specified struct reference.
            </summary>
            <param name="buffer">A 16-byte struct.</param>
            <returns>A 16-byte span mapping from the specified struct reference.</returns>
        </member>
        <member name="M:Monocypher.Monocypher.AsReadOnlySpan(Monocypher.Monocypher.Byte24@)">
            <summary>
            Returns a 24-byte span from the specified struct reference.
            </summary>
            <param name="buffer">A 24-byte struct.</param>
            <returns>A 24-byte span mapping from the specified struct reference.</returns>
        </member>
        <member name="M:Monocypher.Monocypher.AsReadOnlySpan(Monocypher.Monocypher.Byte32@)">
            <summary>
            Returns a 32-byte span from the specified struct reference.
            </summary>
            <param name="buffer">A 32-byte struct.</param>
            <returns>A 32-byte span mapping from the specified struct reference.</returns>
        </member>
        <member name="M:Monocypher.Monocypher.AsReadOnlySpan(Monocypher.Monocypher.Byte64@)">
            <summary>
            Returns a 64-byte span from the specified struct reference.
            </summary>
            <param name="buffer">A 64-byte struct.</param>
            <returns>A 64-byte span mapping from the specified struct reference.</returns>
        </member>
        <member name="T:Monocypher.Monocypher.size_t">
            <summary>
            A native int size (e.g 8 bytes for a 64bit processor, 4 bytes for a 32bit processor).
            </summary>
        </member>
        <member name="M:Monocypher.Monocypher.ToHexBytes(System.ReadOnlySpan{System.Byte},System.Text.StringBuilder)">
            <summary>
            Converts the input span to hexadecimal bytes representation (e.g "0x12, 0xaf, 0x56...")
            </summary>
            <param name="buffer">The buffer to convert to hex bytes.</param>
            <param name="builder">The builder to received hexadecimal bytes.</param>
        </member>
        <member name="M:Monocypher.Monocypher.ToHexBytes(System.ReadOnlySpan{System.Byte})">
            <summary>
            Converts the input span to hexadecimal bytes representation (e.g "0x12, 0xaf, 0x56...")
            </summary>
            <param name="buffer">The buffer to convert to hex bytes.</param>
            <returns>A string representation with hexadecimal bytes from the input span buffer.</returns>
        </member>
        <member name="M:Monocypher.Monocypher.ToHexBytes(System.Span{System.Byte},System.Text.StringBuilder)">
            <summary>
            Converts the input span to hexadecimal bytes representation (e.g "0x12, 0xaf, 0x56...")
            </summary>
            <param name="buffer">The buffer to convert to hex bytes.</param>
            <param name="builder">The builder to received hexadecimal bytes.</param>
        </member>
        <member name="M:Monocypher.Monocypher.ToHexBytes(System.Span{System.Byte})">
            <summary>
            Converts the input span to hexadecimal bytes representation (e.g "0x12, 0xaf, 0x56...")
            </summary>
            <param name="buffer">The buffer to convert to hex bytes.</param>
            <returns>A string representation with hexadecimal bytes from the input span buffer.</returns>
        </member>
        <member name="T:Monocypher.Monocypher.Byte8">
            <summary>
            A 8-byte struct.
            </summary>
        </member>
        <member name="T:Monocypher.Monocypher.Byte12">
            <summary>
            A 12-byte struct.
            </summary>
        </member>
        <member name="T:Monocypher.Monocypher.Byte16">
            <summary>
            A 16-byte struct.
            </summary>
        </member>
        <member name="T:Monocypher.Monocypher.Byte24">
            <summary>
            A 24-byte struct.
            </summary>
        </member>
        <member name="T:Monocypher.Monocypher.Byte32">
            <summary>
            A 32-byte struct.
            </summary>
        </member>
        <member name="T:Monocypher.Monocypher.Byte64">
            <summary>
            A 64-byte struct.
            </summary>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_chacha20(System.Span{System.Byte},System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte})">
             <summary>
             
             These functions provide an interface for the Chacha20 encryption primitive.
             <br/>
             
             Chacha20 is a low-level primitive. Consider using authenticated encryption,
               implemented by <see cref="M:Monocypher.Monocypher.crypto_lock(Monocypher.Monocypher.Byte16@,System.IntPtr,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte24@,System.IntPtr,Monocypher.Monocypher.size_t)"/>.
             <br/>
            
             This overrides considers plain_text input as if it was composed of all of input zero.
             
             </summary>
             <param name="key">A 32-byte secret key.</param>
             <param name="nonce">A 8-byte buffer. An 8-byte or 24-byte number, used only once with any given key. It does
                   not need to be secret or random, but it does have to be unique. Repeating
                   a nonce with the same key reveals the XOR of two different messages, which
                   allows decryption. 24-byte nonces can be selected at random. 8-byte nonces
                   cannot. They are too small, and the same
                   nonce may be selected twice by accident. See
                   intro(3monocypher) for advice about
                   generating random numbers (use the operating system's random number
                   generator).</param>
             <param name="cipher_text">The encrypted message.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_xchacha20(System.Span{System.Byte},System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte})">
             <summary>
             
             These functions provide an interface for the Chacha20 encryption primitive.
             <br/>
             
             Chacha20 is a low-level primitive. Consider using authenticated encryption,
               implemented by <see cref="M:Monocypher.Monocypher.crypto_lock(Monocypher.Monocypher.Byte16@,System.IntPtr,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte24@,System.IntPtr,Monocypher.Monocypher.size_t)"/>.
             <br/>
             
             This overrides considers plain_text input as if it was composed of all of input zero.
            
             </summary>
             <param name="key">A 32-byte secret key.</param>
             <param name="nonce">A 24-byte buffer. An 8-byte or 24-byte number, used only once with any given key. It does
                   not need to be secret or random, but it does have to be unique. Repeating
                   a nonce with the same key reveals the XOR of two different messages, which
                   allows decryption. 24-byte nonces can be selected at random. 8-byte nonces
                   cannot. They are too small, and the same
                   nonce may be selected twice by accident. See
                   intro(3monocypher) for advice about
                   generating random numbers (use the operating system's random number
                   generator).</param>
             <param name="cipher_text">The encrypted message.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_chacha20_ctr(System.Span{System.Byte},System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.UInt64)">
            <summary>
            
            These functions provide an interface for the Chacha20 encryption primitive.
            <br/>
            
            Chacha20 is a low-level primitive. Consider using authenticated encryption,
              implemented by <see cref="M:Monocypher.Monocypher.crypto_lock(Monocypher.Monocypher.Byte16@,System.IntPtr,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte24@,System.IntPtr,Monocypher.Monocypher.size_t)"/>.
            <br/>
            
            This overrides considers plain_text input as if it was composed of all of input zero.
            
            </summary>
            <param name="key">A 32-byte secret key.</param>
            <param name="nonce">A 8-byte buffer. An 8-byte or 24-byte number, used only once with any given key. It does
                  not need to be secret or random, but it does have to be unique. Repeating
                  a nonce with the same key reveals the XOR of two different messages, which
                  allows decryption. 24-byte nonces can be selected at random. 8-byte nonces
                  cannot. They are too small, and the same
                  nonce may be selected twice by accident. See
                  intro(3monocypher) for advice about
                  generating random numbers (use the operating system's random number
                  generator).</param>
            <param name="cipher_text">The encrypted message.</param>
            <param name="ctr">The number of 64-byte blocks since the beginning of the stream.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_xchacha20_ctr(System.Span{System.Byte},System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.UInt64)">
            <summary>
            
            These functions provide an interface for the Chacha20 encryption primitive.
            <br/>
            
            Chacha20 is a low-level primitive. Consider using authenticated encryption,
              implemented by <see cref="M:Monocypher.Monocypher.crypto_lock(Monocypher.Monocypher.Byte16@,System.IntPtr,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte24@,System.IntPtr,Monocypher.Monocypher.size_t)"/>.
            <br/>
            
            This overrides considers plain_text input as if it was composed of all of input zero.
            
            </summary>
            <param name="key">A 32-byte secret key.</param>
            <param name="nonce">A 24-byte buffer. An 8-byte or 24-byte number, used only once with any given key. It does
                  not need to be secret or random, but it does have to be unique. Repeating
                  a nonce with the same key reveals the XOR of two different messages, which
                  allows decryption. 24-byte nonces can be selected at random. 8-byte nonces
                  cannot. They are too small, and the same
                  nonce may be selected twice by accident. See
                  intro(3monocypher) for advice about
                  generating random numbers (use the operating system's random number
                  generator).</param>
            <param name="cipher_text">The encrypted message.</param>
            <param name="ctr">The number of 64-byte blocks since the beginning of the stream.</param>
        </member>
        <member name="T:Monocypher.Monocypher.crypto_sign_vtable">
            <summary>
            Vtable for EdDSA with a custom hash.
            Instantiate it to define a custom hash.
            Its size, contents, and layout, are part of the public API.
            </summary>
        </member>
        <member name="T:Monocypher.Monocypher.crypto_poly1305_ctx">
            <summary>
            Poly1305
            </summary>
        </member>
        <member name="F:Monocypher.Monocypher.crypto_poly1305_ctx.r">
            <summary>
            constant multiplier (from the secret key)
            </summary>
        </member>
        <member name="F:Monocypher.Monocypher.crypto_poly1305_ctx.h">
            <summary>
            accumulated hash
            </summary>
        </member>
        <member name="F:Monocypher.Monocypher.crypto_poly1305_ctx.c">
            <summary>
            chunk of the message
            </summary>
        </member>
        <member name="F:Monocypher.Monocypher.crypto_poly1305_ctx.pad">
            <summary>
            random number added at the end (from the secret key)
            </summary>
        </member>
        <member name="F:Monocypher.Monocypher.crypto_poly1305_ctx.c_idx">
            <summary>
            How many bytes are there in the chunk.
            </summary>
        </member>
        <member name="T:Monocypher.Monocypher.crypto_blake2b_ctx">
            <summary>
            Hash (Blake2b)
            </summary>
        </member>
        <member name="T:Monocypher.Monocypher.crypto_sign_ctx_abstract">
            <summary>
            Signatures (EdDSA)
            </summary>
        </member>
        <member name="T:Monocypher.Monocypher.crypto_sha512_ctx">
            <summary>
            Do not rely on the size or content on any of those types,
            they may change without notice.
            </summary>
        </member>
        <member name="T:Monocypher.Monocypher.crypto_check_ctx_abstract">
            <summary>
            Signatures (EdDSA)
            </summary>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_verify16(Monocypher.Monocypher.Byte16@,Monocypher.Monocypher.Byte16@)">
            <summary>
            
            Cryptographic operations often require comparison of secrets or values derived
              from secrets. Standard comparison functions like
              memcmp() tend to exit when they find the
              first difference, leaking information through timing differences.
            <br/>
            
            As an example, say a message authentication code (MAC) is sent over the network
              along with a message, but the correct MAC is secret. If the attacker attempts
              a forgery, one does not want to reveal &#x201C;your MAC is wrong,
              and it took 384 microseconds to tell&#x201D;. If
              the next attempt takes 462 microseconds instead, it tells the attacker they
              just guessed a byte correctly. That way, an attacker can derive the correct
              MAC byte by byte, and successfully forge a message. This has lead to practical
              attacks in the past.
            <br/>
            
            To avoid such catastrophic failure,
              <see cref="M:Monocypher.Monocypher.crypto_verify16(Monocypher.Monocypher.Byte16@,Monocypher.Monocypher.Byte16@)"/>(),
              <see cref="M:Monocypher.Monocypher.crypto_verify32(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>() and
              <see cref="M:Monocypher.Monocypher.crypto_verify64(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte64@)"/>() provide comparison
              functions whose timing is independent from the content of their input. They
              compare the first 16, 32, or 64 bytes of the two byte arrays
              <paramref name="a"/> and <paramref name="b"/>.
            <br/>
            
            When in doubt, prefer these functions over
              memcmp().
            
            </summary>
            <param name="a">A 16-byte buffer. See Monocypher manual for more details.</param>
            <param name="b">A 16-byte buffer. See Monocypher manual for more details.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_verify16(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte})">
            <summary>
            
            Cryptographic operations often require comparison of secrets or values derived
              from secrets. Standard comparison functions like
              memcmp() tend to exit when they find the
              first difference, leaking information through timing differences.
            <br/>
            
            As an example, say a message authentication code (MAC) is sent over the network
              along with a message, but the correct MAC is secret. If the attacker attempts
              a forgery, one does not want to reveal &#x201C;your MAC is wrong,
              and it took 384 microseconds to tell&#x201D;. If
              the next attempt takes 462 microseconds instead, it tells the attacker they
              just guessed a byte correctly. That way, an attacker can derive the correct
              MAC byte by byte, and successfully forge a message. This has lead to practical
              attacks in the past.
            <br/>
            
            To avoid such catastrophic failure,
              <see cref="M:Monocypher.Monocypher.crypto_verify16(Monocypher.Monocypher.Byte16@,Monocypher.Monocypher.Byte16@)"/>(),
              <see cref="M:Monocypher.Monocypher.crypto_verify32(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>() and
              <see cref="M:Monocypher.Monocypher.crypto_verify64(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte64@)"/>() provide comparison
              functions whose timing is independent from the content of their input. They
              compare the first 16, 32, or 64 bytes of the two byte arrays
              <paramref name="a"/> and <paramref name="b"/>.
            <br/>
            
            When in doubt, prefer these functions over
              memcmp().
            
            </summary>
            <param name="a">A 16-byte buffer. See Monocypher manual for more details.</param>
            <param name="b">A 16-byte buffer. See Monocypher manual for more details.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_verify32(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)">
            <summary>
            
            Cryptographic operations often require comparison of secrets or values derived
              from secrets. Standard comparison functions like
              memcmp() tend to exit when they find the
              first difference, leaking information through timing differences.
            <br/>
            
            As an example, say a message authentication code (MAC) is sent over the network
              along with a message, but the correct MAC is secret. If the attacker attempts
              a forgery, one does not want to reveal &#x201C;your MAC is wrong,
              and it took 384 microseconds to tell&#x201D;. If
              the next attempt takes 462 microseconds instead, it tells the attacker they
              just guessed a byte correctly. That way, an attacker can derive the correct
              MAC byte by byte, and successfully forge a message. This has lead to practical
              attacks in the past.
            <br/>
            
            To avoid such catastrophic failure,
              <see cref="M:Monocypher.Monocypher.crypto_verify16(Monocypher.Monocypher.Byte16@,Monocypher.Monocypher.Byte16@)"/>(),
              <see cref="M:Monocypher.Monocypher.crypto_verify32(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>() and
              <see cref="M:Monocypher.Monocypher.crypto_verify64(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte64@)"/>() provide comparison
              functions whose timing is independent from the content of their input. They
              compare the first 16, 32, or 64 bytes of the two byte arrays
              <paramref name="a"/> and <paramref name="b"/>.
            <br/>
            
            When in doubt, prefer these functions over
              memcmp().
            
            </summary>
            <param name="a">A 32-byte buffer. See Monocypher manual for more details.</param>
            <param name="b">A 32-byte buffer. See Monocypher manual for more details.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_verify32(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte})">
            <summary>
            
            Cryptographic operations often require comparison of secrets or values derived
              from secrets. Standard comparison functions like
              memcmp() tend to exit when they find the
              first difference, leaking information through timing differences.
            <br/>
            
            As an example, say a message authentication code (MAC) is sent over the network
              along with a message, but the correct MAC is secret. If the attacker attempts
              a forgery, one does not want to reveal &#x201C;your MAC is wrong,
              and it took 384 microseconds to tell&#x201D;. If
              the next attempt takes 462 microseconds instead, it tells the attacker they
              just guessed a byte correctly. That way, an attacker can derive the correct
              MAC byte by byte, and successfully forge a message. This has lead to practical
              attacks in the past.
            <br/>
            
            To avoid such catastrophic failure,
              <see cref="M:Monocypher.Monocypher.crypto_verify16(Monocypher.Monocypher.Byte16@,Monocypher.Monocypher.Byte16@)"/>(),
              <see cref="M:Monocypher.Monocypher.crypto_verify32(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>() and
              <see cref="M:Monocypher.Monocypher.crypto_verify64(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte64@)"/>() provide comparison
              functions whose timing is independent from the content of their input. They
              compare the first 16, 32, or 64 bytes of the two byte arrays
              <paramref name="a"/> and <paramref name="b"/>.
            <br/>
            
            When in doubt, prefer these functions over
              memcmp().
            
            </summary>
            <param name="a">A 32-byte buffer. See Monocypher manual for more details.</param>
            <param name="b">A 32-byte buffer. See Monocypher manual for more details.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_verify64(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte64@)">
            <summary>
            
            Cryptographic operations often require comparison of secrets or values derived
              from secrets. Standard comparison functions like
              memcmp() tend to exit when they find the
              first difference, leaking information through timing differences.
            <br/>
            
            As an example, say a message authentication code (MAC) is sent over the network
              along with a message, but the correct MAC is secret. If the attacker attempts
              a forgery, one does not want to reveal &#x201C;your MAC is wrong,
              and it took 384 microseconds to tell&#x201D;. If
              the next attempt takes 462 microseconds instead, it tells the attacker they
              just guessed a byte correctly. That way, an attacker can derive the correct
              MAC byte by byte, and successfully forge a message. This has lead to practical
              attacks in the past.
            <br/>
            
            To avoid such catastrophic failure,
              <see cref="M:Monocypher.Monocypher.crypto_verify16(Monocypher.Monocypher.Byte16@,Monocypher.Monocypher.Byte16@)"/>(),
              <see cref="M:Monocypher.Monocypher.crypto_verify32(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>() and
              <see cref="M:Monocypher.Monocypher.crypto_verify64(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte64@)"/>() provide comparison
              functions whose timing is independent from the content of their input. They
              compare the first 16, 32, or 64 bytes of the two byte arrays
              <paramref name="a"/> and <paramref name="b"/>.
            <br/>
            
            When in doubt, prefer these functions over
              memcmp().
            
            </summary>
            <param name="a">A 64-byte buffer. See Monocypher manual for more details.</param>
            <param name="b">A 64-byte buffer. See Monocypher manual for more details.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_verify64(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte})">
            <summary>
            
            Cryptographic operations often require comparison of secrets or values derived
              from secrets. Standard comparison functions like
              memcmp() tend to exit when they find the
              first difference, leaking information through timing differences.
            <br/>
            
            As an example, say a message authentication code (MAC) is sent over the network
              along with a message, but the correct MAC is secret. If the attacker attempts
              a forgery, one does not want to reveal &#x201C;your MAC is wrong,
              and it took 384 microseconds to tell&#x201D;. If
              the next attempt takes 462 microseconds instead, it tells the attacker they
              just guessed a byte correctly. That way, an attacker can derive the correct
              MAC byte by byte, and successfully forge a message. This has lead to practical
              attacks in the past.
            <br/>
            
            To avoid such catastrophic failure,
              <see cref="M:Monocypher.Monocypher.crypto_verify16(Monocypher.Monocypher.Byte16@,Monocypher.Monocypher.Byte16@)"/>(),
              <see cref="M:Monocypher.Monocypher.crypto_verify32(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>() and
              <see cref="M:Monocypher.Monocypher.crypto_verify64(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte64@)"/>() provide comparison
              functions whose timing is independent from the content of their input. They
              compare the first 16, 32, or 64 bytes of the two byte arrays
              <paramref name="a"/> and <paramref name="b"/>.
            <br/>
            
            When in doubt, prefer these functions over
              memcmp().
            
            </summary>
            <param name="a">A 64-byte buffer. See Monocypher manual for more details.</param>
            <param name="b">A 64-byte buffer. See Monocypher manual for more details.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_wipe(System.IntPtr,Monocypher.Monocypher.size_t)">
            <summary>
            <see cref="M:Monocypher.Monocypher.crypto_wipe(System.IntPtr,Monocypher.Monocypher.size_t)"/>() securely erases sensitive data
              in memory.
            <br/>
            
            Sensitive data (such as cryptographic keys or secret plaintexts) should be
              erased from memory as early as possible, to minimise the window in which it
              can be leaked. Standard functions like memset and bzero are not safe to use,
              as the compiler may decide they have no effect and optimise them out.
            <br/>
            
            </summary>
            <param name="secret">The buffer to erase.</param>
            <param name="size">See Monocypher manual for more details.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_wipe(System.Span{System.Byte})">
            <summary>
            <see cref="M:Monocypher.Monocypher.crypto_wipe(System.IntPtr,Monocypher.Monocypher.size_t)"/>() securely erases sensitive data
              in memory.
            <br/>
            
            Sensitive data (such as cryptographic keys or secret plaintexts) should be
              erased from memory as early as possible, to minimise the window in which it
              can be leaked. Standard functions like memset and bzero are not safe to use,
              as the compiler may decide they have no effect and optimise them out.
            <br/>
            
            </summary>
            <param name="secret">The buffer to erase.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_lock(Monocypher.Monocypher.Byte16@,System.IntPtr,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte24@,System.IntPtr,Monocypher.Monocypher.size_t)">
            <summary>
            <see cref="M:Monocypher.Monocypher.crypto_lock(Monocypher.Monocypher.Byte16@,System.IntPtr,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte24@,System.IntPtr,Monocypher.Monocypher.size_t)"/>() encrypts and authenticates a
              plaintext. It can be decrypted by
              <see cref="M:Monocypher.Monocypher.crypto_unlock(System.IntPtr,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte24@,Monocypher.Monocypher.Byte16@,System.IntPtr,Monocypher.Monocypher.size_t)"/>().
            </summary>
            <param name="key">A 32-byte session key, shared between the sender and the recipient. It
                  must be secret and random. Different methods can be used to produce and
                  exchange this key, such as Diffie-Hellman key exchange, password key
                  derivation (the password must be communicated on a secure channel), or
                  even meeting physically. See
                  <see cref="M:Monocypher.Monocypher.crypto_key_exchange(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/> for key
                  exchange, and <see cref="M:Monocypher.Monocypher.crypto_argon2i(System.IntPtr,System.UInt32,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr,System.UInt32,System.IntPtr,System.UInt32)"/> for
                  password key derivation.</param>
            <param name="nonce">A 24-byte number, used only once with any given session key. It does not
                  need to be secret or random, but it does have to be unique.
                  Never use the same nonce twice with the same
                  key. This would reveal the XOR of 2 different messages, which allows
                  decryption and forgeries. The easiest (and recommended) way to generate
                  this nonce is to select it at random. See
                  intro(3monocypher) about random number
                  generation (use your operating system's random number generator).</param>
            <param name="mac">A 16-byte message authentication code (MAC),
                  that can only be produced by someone who knows the session key. This
                  guarantee cannot be upheld if a nonce has been reused with the session
                  key, because doing so allows the attacker to learn the authentication key
                  associated with that nonce. The MAC is intended to be sent along with the
                  ciphertext.</param>
            <param name="plain_text">The secret message. Its contents will be kept hidden from attackers. Its
                  length however, will not. Be careful when
                  combining encryption with compression. See
                  intro(3monocypher) for details.</param>
            <param name="cipher_text">The encrypted message.</param>
            <param name="text_size">Length of both <paramref name="plain_text andand"/><paramref name="cipher_text"/>, in bytes.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_lock(System.Span{System.Byte},System.Span{System.Byte},System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte})">
            <summary>
            <see cref="M:Monocypher.Monocypher.crypto_lock(Monocypher.Monocypher.Byte16@,System.IntPtr,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte24@,System.IntPtr,Monocypher.Monocypher.size_t)"/>() encrypts and authenticates a
              plaintext. It can be decrypted by
              <see cref="M:Monocypher.Monocypher.crypto_unlock(System.IntPtr,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte24@,Monocypher.Monocypher.Byte16@,System.IntPtr,Monocypher.Monocypher.size_t)"/>().
            </summary>
            <param name="key">A 32-byte session key, shared between the sender and the recipient. It
                  must be secret and random. Different methods can be used to produce and
                  exchange this key, such as Diffie-Hellman key exchange, password key
                  derivation (the password must be communicated on a secure channel), or
                  even meeting physically. See
                  <see cref="M:Monocypher.Monocypher.crypto_key_exchange(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/> for key
                  exchange, and <see cref="M:Monocypher.Monocypher.crypto_argon2i(System.IntPtr,System.UInt32,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr,System.UInt32,System.IntPtr,System.UInt32)"/> for
                  password key derivation.</param>
            <param name="nonce">A 24-byte number, used only once with any given session key. It does not
                  need to be secret or random, but it does have to be unique.
                  Never use the same nonce twice with the same
                  key. This would reveal the XOR of 2 different messages, which allows
                  decryption and forgeries. The easiest (and recommended) way to generate
                  this nonce is to select it at random. See
                  intro(3monocypher) about random number
                  generation (use your operating system's random number generator).</param>
            <param name="mac">A 16-byte message authentication code (MAC),
                  that can only be produced by someone who knows the session key. This
                  guarantee cannot be upheld if a nonce has been reused with the session
                  key, because doing so allows the attacker to learn the authentication key
                  associated with that nonce. The MAC is intended to be sent along with the
                  ciphertext.</param>
            <param name="plain_text">The secret message. Its contents will be kept hidden from attackers. Its
                  length however, will not. Be careful when
                  combining encryption with compression. See
                  intro(3monocypher) for details.</param>
            <param name="cipher_text">The encrypted message.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_unlock(System.IntPtr,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte24@,Monocypher.Monocypher.Byte16@,System.IntPtr,Monocypher.Monocypher.size_t)">
            <summary>
            <see cref="M:Monocypher.Monocypher.crypto_lock(Monocypher.Monocypher.Byte16@,System.IntPtr,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte24@,System.IntPtr,Monocypher.Monocypher.size_t)"/>() encrypts and authenticates a
              plaintext. It can be decrypted by
              <see cref="M:Monocypher.Monocypher.crypto_unlock(System.IntPtr,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte24@,Monocypher.Monocypher.Byte16@,System.IntPtr,Monocypher.Monocypher.size_t)"/>().
            </summary>
            <param name="key">A 32-byte session key, shared between the sender and the recipient. It
                  must be secret and random. Different methods can be used to produce and
                  exchange this key, such as Diffie-Hellman key exchange, password key
                  derivation (the password must be communicated on a secure channel), or
                  even meeting physically. See
                  <see cref="M:Monocypher.Monocypher.crypto_key_exchange(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/> for key
                  exchange, and <see cref="M:Monocypher.Monocypher.crypto_argon2i(System.IntPtr,System.UInt32,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr,System.UInt32,System.IntPtr,System.UInt32)"/> for
                  password key derivation.</param>
            <param name="nonce">A 24-byte number, used only once with any given session key. It does not
                  need to be secret or random, but it does have to be unique.
                  Never use the same nonce twice with the same
                  key. This would reveal the XOR of 2 different messages, which allows
                  decryption and forgeries. The easiest (and recommended) way to generate
                  this nonce is to select it at random. See
                  intro(3monocypher) about random number
                  generation (use your operating system's random number generator).</param>
            <param name="mac">A 16-byte message authentication code (MAC),
                  that can only be produced by someone who knows the session key. This
                  guarantee cannot be upheld if a nonce has been reused with the session
                  key, because doing so allows the attacker to learn the authentication key
                  associated with that nonce. The MAC is intended to be sent along with the
                  ciphertext.</param>
            <param name="plain_text">The secret message. Its contents will be kept hidden from attackers. Its
                  length however, will not. Be careful when
                  combining encryption with compression. See
                  intro(3monocypher) for details.</param>
            <param name="cipher_text">The encrypted message.</param>
            <param name="text_size">Length of both <paramref name="plain_text andand"/><paramref name="cipher_text"/>, in bytes.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_unlock(System.Span{System.Byte},System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte})">
            <summary>
            <see cref="M:Monocypher.Monocypher.crypto_lock(Monocypher.Monocypher.Byte16@,System.IntPtr,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte24@,System.IntPtr,Monocypher.Monocypher.size_t)"/>() encrypts and authenticates a
              plaintext. It can be decrypted by
              <see cref="M:Monocypher.Monocypher.crypto_unlock(System.IntPtr,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte24@,Monocypher.Monocypher.Byte16@,System.IntPtr,Monocypher.Monocypher.size_t)"/>().
            </summary>
            <param name="key">A 32-byte session key, shared between the sender and the recipient. It
                  must be secret and random. Different methods can be used to produce and
                  exchange this key, such as Diffie-Hellman key exchange, password key
                  derivation (the password must be communicated on a secure channel), or
                  even meeting physically. See
                  <see cref="M:Monocypher.Monocypher.crypto_key_exchange(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/> for key
                  exchange, and <see cref="M:Monocypher.Monocypher.crypto_argon2i(System.IntPtr,System.UInt32,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr,System.UInt32,System.IntPtr,System.UInt32)"/> for
                  password key derivation.</param>
            <param name="nonce">A 24-byte number, used only once with any given session key. It does not
                  need to be secret or random, but it does have to be unique.
                  Never use the same nonce twice with the same
                  key. This would reveal the XOR of 2 different messages, which allows
                  decryption and forgeries. The easiest (and recommended) way to generate
                  this nonce is to select it at random. See
                  intro(3monocypher) about random number
                  generation (use your operating system's random number generator).</param>
            <param name="mac">A 16-byte message authentication code (MAC),
                  that can only be produced by someone who knows the session key. This
                  guarantee cannot be upheld if a nonce has been reused with the session
                  key, because doing so allows the attacker to learn the authentication key
                  associated with that nonce. The MAC is intended to be sent along with the
                  ciphertext.</param>
            <param name="plain_text">The secret message. Its contents will be kept hidden from attackers. Its
                  length however, will not. Be careful when
                  combining encryption with compression. See
                  intro(3monocypher) for details.</param>
            <param name="cipher_text">The encrypted message.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_lock_aead(Monocypher.Monocypher.Byte16@,System.IntPtr,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte24@,System.IntPtr,Monocypher.Monocypher.size_t,System.IntPtr,Monocypher.Monocypher.size_t)">
            <summary>
            <see cref="M:Monocypher.Monocypher.crypto_lock(Monocypher.Monocypher.Byte16@,System.IntPtr,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte24@,System.IntPtr,Monocypher.Monocypher.size_t)"/>() encrypts and authenticates a
              plaintext. It can be decrypted by
              <see cref="M:Monocypher.Monocypher.crypto_unlock(System.IntPtr,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte24@,Monocypher.Monocypher.Byte16@,System.IntPtr,Monocypher.Monocypher.size_t)"/>().
            </summary>
            <param name="key">A 32-byte session key, shared between the sender and the recipient. It
                  must be secret and random. Different methods can be used to produce and
                  exchange this key, such as Diffie-Hellman key exchange, password key
                  derivation (the password must be communicated on a secure channel), or
                  even meeting physically. See
                  <see cref="M:Monocypher.Monocypher.crypto_key_exchange(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/> for key
                  exchange, and <see cref="M:Monocypher.Monocypher.crypto_argon2i(System.IntPtr,System.UInt32,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr,System.UInt32,System.IntPtr,System.UInt32)"/> for
                  password key derivation.</param>
            <param name="nonce">A 24-byte number, used only once with any given session key. It does not
                  need to be secret or random, but it does have to be unique.
                  Never use the same nonce twice with the same
                  key. This would reveal the XOR of 2 different messages, which allows
                  decryption and forgeries. The easiest (and recommended) way to generate
                  this nonce is to select it at random. See
                  intro(3monocypher) about random number
                  generation (use your operating system's random number generator).</param>
            <param name="mac">A 16-byte message authentication code (MAC),
                  that can only be produced by someone who knows the session key. This
                  guarantee cannot be upheld if a nonce has been reused with the session
                  key, because doing so allows the attacker to learn the authentication key
                  associated with that nonce. The MAC is intended to be sent along with the
                  ciphertext.</param>
            <param name="plain_text">The secret message. Its contents will be kept hidden from attackers. Its
                  length however, will not. Be careful when
                  combining encryption with compression. See
                  intro(3monocypher) for details.</param>
            <param name="cipher_text">The encrypted message.</param>
            <param name="text_size">Length of both <paramref name="plain_text andand"/><paramref name="cipher_text"/>, in bytes.</param>
            <param name="ad">See Monocypher manual for more details.</param>
            <param name="ad_size">See Monocypher manual for more details.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_lock_aead(System.Span{System.Byte},System.Span{System.Byte},System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte})">
            <summary>
            <see cref="M:Monocypher.Monocypher.crypto_lock(Monocypher.Monocypher.Byte16@,System.IntPtr,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte24@,System.IntPtr,Monocypher.Monocypher.size_t)"/>() encrypts and authenticates a
              plaintext. It can be decrypted by
              <see cref="M:Monocypher.Monocypher.crypto_unlock(System.IntPtr,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte24@,Monocypher.Monocypher.Byte16@,System.IntPtr,Monocypher.Monocypher.size_t)"/>().
            </summary>
            <param name="key">A 32-byte session key, shared between the sender and the recipient. It
                  must be secret and random. Different methods can be used to produce and
                  exchange this key, such as Diffie-Hellman key exchange, password key
                  derivation (the password must be communicated on a secure channel), or
                  even meeting physically. See
                  <see cref="M:Monocypher.Monocypher.crypto_key_exchange(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/> for key
                  exchange, and <see cref="M:Monocypher.Monocypher.crypto_argon2i(System.IntPtr,System.UInt32,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr,System.UInt32,System.IntPtr,System.UInt32)"/> for
                  password key derivation.</param>
            <param name="nonce">A 24-byte number, used only once with any given session key. It does not
                  need to be secret or random, but it does have to be unique.
                  Never use the same nonce twice with the same
                  key. This would reveal the XOR of 2 different messages, which allows
                  decryption and forgeries. The easiest (and recommended) way to generate
                  this nonce is to select it at random. See
                  intro(3monocypher) about random number
                  generation (use your operating system's random number generator).</param>
            <param name="mac">A 16-byte message authentication code (MAC),
                  that can only be produced by someone who knows the session key. This
                  guarantee cannot be upheld if a nonce has been reused with the session
                  key, because doing so allows the attacker to learn the authentication key
                  associated with that nonce. The MAC is intended to be sent along with the
                  ciphertext.</param>
            <param name="plain_text">The secret message. Its contents will be kept hidden from attackers. Its
                  length however, will not. Be careful when
                  combining encryption with compression. See
                  intro(3monocypher) for details.</param>
            <param name="cipher_text">The encrypted message.</param>
            <param name="ad">See Monocypher manual for more details.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_unlock_aead(System.IntPtr,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte24@,Monocypher.Monocypher.Byte16@,System.IntPtr,Monocypher.Monocypher.size_t,System.IntPtr,Monocypher.Monocypher.size_t)">
            <summary>
            <see cref="M:Monocypher.Monocypher.crypto_lock(Monocypher.Monocypher.Byte16@,System.IntPtr,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte24@,System.IntPtr,Monocypher.Monocypher.size_t)"/>() encrypts and authenticates a
              plaintext. It can be decrypted by
              <see cref="M:Monocypher.Monocypher.crypto_unlock(System.IntPtr,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte24@,Monocypher.Monocypher.Byte16@,System.IntPtr,Monocypher.Monocypher.size_t)"/>().
            </summary>
            <param name="key">A 32-byte session key, shared between the sender and the recipient. It
                  must be secret and random. Different methods can be used to produce and
                  exchange this key, such as Diffie-Hellman key exchange, password key
                  derivation (the password must be communicated on a secure channel), or
                  even meeting physically. See
                  <see cref="M:Monocypher.Monocypher.crypto_key_exchange(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/> for key
                  exchange, and <see cref="M:Monocypher.Monocypher.crypto_argon2i(System.IntPtr,System.UInt32,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr,System.UInt32,System.IntPtr,System.UInt32)"/> for
                  password key derivation.</param>
            <param name="nonce">A 24-byte number, used only once with any given session key. It does not
                  need to be secret or random, but it does have to be unique.
                  Never use the same nonce twice with the same
                  key. This would reveal the XOR of 2 different messages, which allows
                  decryption and forgeries. The easiest (and recommended) way to generate
                  this nonce is to select it at random. See
                  intro(3monocypher) about random number
                  generation (use your operating system's random number generator).</param>
            <param name="mac">A 16-byte message authentication code (MAC),
                  that can only be produced by someone who knows the session key. This
                  guarantee cannot be upheld if a nonce has been reused with the session
                  key, because doing so allows the attacker to learn the authentication key
                  associated with that nonce. The MAC is intended to be sent along with the
                  ciphertext.</param>
            <param name="plain_text">The secret message. Its contents will be kept hidden from attackers. Its
                  length however, will not. Be careful when
                  combining encryption with compression. See
                  intro(3monocypher) for details.</param>
            <param name="cipher_text">The encrypted message.</param>
            <param name="text_size">Length of both <paramref name="plain_text andand"/><paramref name="cipher_text"/>, in bytes.</param>
            <param name="ad">See Monocypher manual for more details.</param>
            <param name="ad_size">See Monocypher manual for more details.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_unlock_aead(System.Span{System.Byte},System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte})">
            <summary>
            <see cref="M:Monocypher.Monocypher.crypto_lock(Monocypher.Monocypher.Byte16@,System.IntPtr,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte24@,System.IntPtr,Monocypher.Monocypher.size_t)"/>() encrypts and authenticates a
              plaintext. It can be decrypted by
              <see cref="M:Monocypher.Monocypher.crypto_unlock(System.IntPtr,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte24@,Monocypher.Monocypher.Byte16@,System.IntPtr,Monocypher.Monocypher.size_t)"/>().
            </summary>
            <param name="key">A 32-byte session key, shared between the sender and the recipient. It
                  must be secret and random. Different methods can be used to produce and
                  exchange this key, such as Diffie-Hellman key exchange, password key
                  derivation (the password must be communicated on a secure channel), or
                  even meeting physically. See
                  <see cref="M:Monocypher.Monocypher.crypto_key_exchange(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/> for key
                  exchange, and <see cref="M:Monocypher.Monocypher.crypto_argon2i(System.IntPtr,System.UInt32,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr,System.UInt32,System.IntPtr,System.UInt32)"/> for
                  password key derivation.</param>
            <param name="nonce">A 24-byte number, used only once with any given session key. It does not
                  need to be secret or random, but it does have to be unique.
                  Never use the same nonce twice with the same
                  key. This would reveal the XOR of 2 different messages, which allows
                  decryption and forgeries. The easiest (and recommended) way to generate
                  this nonce is to select it at random. See
                  intro(3monocypher) about random number
                  generation (use your operating system's random number generator).</param>
            <param name="mac">A 16-byte message authentication code (MAC),
                  that can only be produced by someone who knows the session key. This
                  guarantee cannot be upheld if a nonce has been reused with the session
                  key, because doing so allows the attacker to learn the authentication key
                  associated with that nonce. The MAC is intended to be sent along with the
                  ciphertext.</param>
            <param name="plain_text">The secret message. Its contents will be kept hidden from attackers. Its
                  length however, will not. Be careful when
                  combining encryption with compression. See
                  intro(3monocypher) for details.</param>
            <param name="cipher_text">The encrypted message.</param>
            <param name="ad">See Monocypher manual for more details.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_blake2b(Monocypher.Monocypher.Byte64@,System.IntPtr,Monocypher.Monocypher.size_t)">
            <summary>
            
            BLAKE2b is a fast cryptographically secure hash, based on the ideas of Chacha20.
              It is faster than MD5, yet just as secure as SHA-3.
            <br/>
            
            Note that BLAKE2b itself is not suitable for hashing passwords and deriving keys
              from them; use the <see cref="M:Monocypher.Monocypher.crypto_argon2i(System.IntPtr,System.UInt32,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr,System.UInt32,System.IntPtr,System.UInt32)"/>
              family of functions for that purpose instead.
            <br/>
            
            BLAKE2b is immune to length extension attacks, and as such does not require any
              specific precautions, such as using the HMAC algorithm.
            <br/>
            
            </summary>
            <param name="hash">A 64-byte buffer. The output hash.</param>
            <param name="message">The message to hash. May overlap with
                  <paramref name="hash"/>. May be
                  NULL if
                  <paramref name="message_size"/> is 0.</param>
            <param name="message_size">Length of <paramref name="message"/>, in bytes.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_blake2b(System.Span{System.Byte},System.ReadOnlySpan{System.Byte})">
            <summary>
            
            BLAKE2b is a fast cryptographically secure hash, based on the ideas of Chacha20.
              It is faster than MD5, yet just as secure as SHA-3.
            <br/>
            
            Note that BLAKE2b itself is not suitable for hashing passwords and deriving keys
              from them; use the <see cref="M:Monocypher.Monocypher.crypto_argon2i(System.IntPtr,System.UInt32,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr,System.UInt32,System.IntPtr,System.UInt32)"/>
              family of functions for that purpose instead.
            <br/>
            
            BLAKE2b is immune to length extension attacks, and as such does not require any
              specific precautions, such as using the HMAC algorithm.
            <br/>
            
            </summary>
            <param name="hash">A 64-byte buffer. The output hash.</param>
            <param name="message">The message to hash. May overlap with
                  <paramref name="hash"/>. May be
                  NULL if
                  <paramref name="message_size"/> is 0.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_blake2b_general(System.IntPtr,Monocypher.Monocypher.size_t,System.IntPtr,Monocypher.Monocypher.size_t,System.IntPtr,Monocypher.Monocypher.size_t)">
            <summary>
            
            BLAKE2b is a fast cryptographically secure hash, based on the ideas of Chacha20.
              It is faster than MD5, yet just as secure as SHA-3.
            <br/>
            
            Note that BLAKE2b itself is not suitable for hashing passwords and deriving keys
              from them; use the <see cref="M:Monocypher.Monocypher.crypto_argon2i(System.IntPtr,System.UInt32,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr,System.UInt32,System.IntPtr,System.UInt32)"/>
              family of functions for that purpose instead.
            <br/>
            
            BLAKE2b is immune to length extension attacks, and as such does not require any
              specific precautions, such as using the HMAC algorithm.
            <br/>
            
            </summary>
            <param name="hash">The output hash.</param>
            <param name="hash_size">Length of <paramref name="hash"/>, in bytes. Must be between
                  1 and 64. Anything below 32 is discouraged when using Blake2b as a
                  general-purpose hash function; anything below 16 is discouraged when using
                  Blake2b as a message authentication code.</param>
            <param name="key">Some secret key. One cannot predict the final hash without it. May be
                  NULL if
                  <paramref name="key_size"/> is 0, in which case no key is
                  used. Keys can be used to create a message authentication code (MAC). Use
                  <see cref="M:Monocypher.Monocypher.crypto_verify16(Monocypher.Monocypher.Byte16@,Monocypher.Monocypher.Byte16@)"/>,
                  <see cref="M:Monocypher.Monocypher.crypto_verify32(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>, or
                  <see cref="M:Monocypher.Monocypher.crypto_verify64(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte64@)"/> to compare MACs
                  created this way. Choose the size of the hash accordingly. Users may want
                  to wipe the key with <see cref="M:Monocypher.Monocypher.crypto_wipe(System.IntPtr,Monocypher.Monocypher.size_t)"/>
                  once they are done with it.</param>
            <param name="key_size">Length of <paramref name="key"/>, in bytes. Must be between
                  0 and 64. 32 is a good default.</param>
            <param name="message">The message to hash. May overlap with
                  <paramref name="hash"/>. May be
                  NULL if
                  <paramref name="message_size"/> is 0.</param>
            <param name="message_size">Length of <paramref name="message"/>, in bytes.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_blake2b_general(System.Span{System.Byte},System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte})">
            <summary>
            
            BLAKE2b is a fast cryptographically secure hash, based on the ideas of Chacha20.
              It is faster than MD5, yet just as secure as SHA-3.
            <br/>
            
            Note that BLAKE2b itself is not suitable for hashing passwords and deriving keys
              from them; use the <see cref="M:Monocypher.Monocypher.crypto_argon2i(System.IntPtr,System.UInt32,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr,System.UInt32,System.IntPtr,System.UInt32)"/>
              family of functions for that purpose instead.
            <br/>
            
            BLAKE2b is immune to length extension attacks, and as such does not require any
              specific precautions, such as using the HMAC algorithm.
            <br/>
            
            </summary>
            <param name="hash">The output hash.</param>
            <param name="key">Some secret key. One cannot predict the final hash without it. May be
                  NULL if
                  <paramref name="key_size"/> is 0, in which case no key is
                  used. Keys can be used to create a message authentication code (MAC). Use
                  <see cref="M:Monocypher.Monocypher.crypto_verify16(Monocypher.Monocypher.Byte16@,Monocypher.Monocypher.Byte16@)"/>,
                  <see cref="M:Monocypher.Monocypher.crypto_verify32(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>, or
                  <see cref="M:Monocypher.Monocypher.crypto_verify64(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte64@)"/> to compare MACs
                  created this way. Choose the size of the hash accordingly. Users may want
                  to wipe the key with <see cref="M:Monocypher.Monocypher.crypto_wipe(System.IntPtr,Monocypher.Monocypher.size_t)"/>
                  once they are done with it.</param>
            <param name="message">The message to hash. May overlap with
                  <paramref name="hash"/>. May be
                  NULL if
                  <paramref name="message_size"/> is 0.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_blake2b_init(Monocypher.Monocypher.crypto_blake2b_ctx@)">
            <summary>
            
            BLAKE2b is a fast cryptographically secure hash, based on the ideas of Chacha20.
              It is faster than MD5, yet just as secure as SHA-3.
            <br/>
            
            Note that BLAKE2b itself is not suitable for hashing passwords and deriving keys
              from them; use the <see cref="M:Monocypher.Monocypher.crypto_argon2i(System.IntPtr,System.UInt32,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr,System.UInt32,System.IntPtr,System.UInt32)"/>
              family of functions for that purpose instead.
            <br/>
            
            BLAKE2b is immune to length extension attacks, and as such does not require any
              specific precautions, such as using the HMAC algorithm.
            <br/>
            
            </summary>
            <param name="hash">The output hash.</param>
            <param name="hash_size">Length of <paramref name="hash"/>, in bytes. Must be between
                  1 and 64. Anything below 32 is discouraged when using Blake2b as a
                  general-purpose hash function; anything below 16 is discouraged when using
                  Blake2b as a message authentication code.</param>
            <param name="key">Some secret key. One cannot predict the final hash without it. May be
                  NULL if
                  <paramref name="key_size"/> is 0, in which case no key is
                  used. Keys can be used to create a message authentication code (MAC). Use
                  <see cref="M:Monocypher.Monocypher.crypto_verify16(Monocypher.Monocypher.Byte16@,Monocypher.Monocypher.Byte16@)"/>,
                  <see cref="M:Monocypher.Monocypher.crypto_verify32(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>, or
                  <see cref="M:Monocypher.Monocypher.crypto_verify64(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte64@)"/> to compare MACs
                  created this way. Choose the size of the hash accordingly. Users may want
                  to wipe the key with <see cref="M:Monocypher.Monocypher.crypto_wipe(System.IntPtr,Monocypher.Monocypher.size_t)"/>
                  once they are done with it.</param>
            <param name="key_size">Length of <paramref name="key"/>, in bytes. Must be between
                  0 and 64. 32 is a good default.</param>
            <param name="message">The message to hash. May overlap with
                  <paramref name="hash"/>. May be
                  NULL if
                  <paramref name="message_size"/> is 0.</param>
            <param name="message_size">Length of <paramref name="message"/>, in bytes.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_blake2b_update(Monocypher.Monocypher.crypto_blake2b_ctx@,System.IntPtr,Monocypher.Monocypher.size_t)">
            <summary>
            
            BLAKE2b is a fast cryptographically secure hash, based on the ideas of Chacha20.
              It is faster than MD5, yet just as secure as SHA-3.
            <br/>
            
            Note that BLAKE2b itself is not suitable for hashing passwords and deriving keys
              from them; use the <see cref="M:Monocypher.Monocypher.crypto_argon2i(System.IntPtr,System.UInt32,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr,System.UInt32,System.IntPtr,System.UInt32)"/>
              family of functions for that purpose instead.
            <br/>
            
            BLAKE2b is immune to length extension attacks, and as such does not require any
              specific precautions, such as using the HMAC algorithm.
            <br/>
            
            </summary>
            <param name="message">The message to hash. May overlap with
                  <paramref name="hash"/>. May be
                  NULL if
                  <paramref name="message_size"/> is 0.</param>
            <param name="message_size">Length of <paramref name="message"/>, in bytes.</param>
            <param name="ctx">See Monocypher manual for more details.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_blake2b_update(Monocypher.Monocypher.crypto_blake2b_ctx@,System.ReadOnlySpan{System.Byte})">
            <summary>
            
            BLAKE2b is a fast cryptographically secure hash, based on the ideas of Chacha20.
              It is faster than MD5, yet just as secure as SHA-3.
            <br/>
            
            Note that BLAKE2b itself is not suitable for hashing passwords and deriving keys
              from them; use the <see cref="M:Monocypher.Monocypher.crypto_argon2i(System.IntPtr,System.UInt32,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr,System.UInt32,System.IntPtr,System.UInt32)"/>
              family of functions for that purpose instead.
            <br/>
            
            BLAKE2b is immune to length extension attacks, and as such does not require any
              specific precautions, such as using the HMAC algorithm.
            <br/>
            
            </summary>
            <param name="message">The message to hash. May overlap with
                  <paramref name="hash"/>. May be
                  NULL if
                  <paramref name="message_size"/> is 0.</param>
            <param name="ctx">See Monocypher manual for more details.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_blake2b_final(Monocypher.Monocypher.crypto_blake2b_ctx@,System.IntPtr)">
            <summary>
            
            BLAKE2b is a fast cryptographically secure hash, based on the ideas of Chacha20.
              It is faster than MD5, yet just as secure as SHA-3.
            <br/>
            
            Note that BLAKE2b itself is not suitable for hashing passwords and deriving keys
              from them; use the <see cref="M:Monocypher.Monocypher.crypto_argon2i(System.IntPtr,System.UInt32,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr,System.UInt32,System.IntPtr,System.UInt32)"/>
              family of functions for that purpose instead.
            <br/>
            
            BLAKE2b is immune to length extension attacks, and as such does not require any
              specific precautions, such as using the HMAC algorithm.
            <br/>
            
            </summary>
            <param name="hash">The output hash.</param>
            <param name="ctx">See Monocypher manual for more details.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_blake2b_final(Monocypher.Monocypher.crypto_blake2b_ctx@,System.Span{System.Byte})">
            <summary>
            
            BLAKE2b is a fast cryptographically secure hash, based on the ideas of Chacha20.
              It is faster than MD5, yet just as secure as SHA-3.
            <br/>
            
            Note that BLAKE2b itself is not suitable for hashing passwords and deriving keys
              from them; use the <see cref="M:Monocypher.Monocypher.crypto_argon2i(System.IntPtr,System.UInt32,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr,System.UInt32,System.IntPtr,System.UInt32)"/>
              family of functions for that purpose instead.
            <br/>
            
            BLAKE2b is immune to length extension attacks, and as such does not require any
              specific precautions, such as using the HMAC algorithm.
            <br/>
            
            </summary>
            <param name="hash">The output hash.</param>
            <param name="ctx">See Monocypher manual for more details.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_blake2b_general_init(Monocypher.Monocypher.crypto_blake2b_ctx@,Monocypher.Monocypher.size_t,System.IntPtr,Monocypher.Monocypher.size_t)">
            <summary>
            
            BLAKE2b is a fast cryptographically secure hash, based on the ideas of Chacha20.
              It is faster than MD5, yet just as secure as SHA-3.
            <br/>
            
            Note that BLAKE2b itself is not suitable for hashing passwords and deriving keys
              from them; use the <see cref="M:Monocypher.Monocypher.crypto_argon2i(System.IntPtr,System.UInt32,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr,System.UInt32,System.IntPtr,System.UInt32)"/>
              family of functions for that purpose instead.
            <br/>
            
            BLAKE2b is immune to length extension attacks, and as such does not require any
              specific precautions, such as using the HMAC algorithm.
            <br/>
            
            </summary>
            <param name="hash_size">Length of <paramref name="hash"/>, in bytes. Must be between
                  1 and 64. Anything below 32 is discouraged when using Blake2b as a
                  general-purpose hash function; anything below 16 is discouraged when using
                  Blake2b as a message authentication code.</param>
            <param name="key">Some secret key. One cannot predict the final hash without it. May be
                  NULL if
                  <paramref name="key_size"/> is 0, in which case no key is
                  used. Keys can be used to create a message authentication code (MAC). Use
                  <see cref="M:Monocypher.Monocypher.crypto_verify16(Monocypher.Monocypher.Byte16@,Monocypher.Monocypher.Byte16@)"/>,
                  <see cref="M:Monocypher.Monocypher.crypto_verify32(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>, or
                  <see cref="M:Monocypher.Monocypher.crypto_verify64(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte64@)"/> to compare MACs
                  created this way. Choose the size of the hash accordingly. Users may want
                  to wipe the key with <see cref="M:Monocypher.Monocypher.crypto_wipe(System.IntPtr,Monocypher.Monocypher.size_t)"/>
                  once they are done with it.</param>
            <param name="key_size">Length of <paramref name="key"/>, in bytes. Must be between
                  0 and 64. 32 is a good default.</param>
            <param name="ctx">See Monocypher manual for more details.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_blake2b_general_init(Monocypher.Monocypher.crypto_blake2b_ctx@,Monocypher.Monocypher.size_t,System.ReadOnlySpan{System.Byte})">
            <summary>
            
            BLAKE2b is a fast cryptographically secure hash, based on the ideas of Chacha20.
              It is faster than MD5, yet just as secure as SHA-3.
            <br/>
            
            Note that BLAKE2b itself is not suitable for hashing passwords and deriving keys
              from them; use the <see cref="M:Monocypher.Monocypher.crypto_argon2i(System.IntPtr,System.UInt32,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr,System.UInt32,System.IntPtr,System.UInt32)"/>
              family of functions for that purpose instead.
            <br/>
            
            BLAKE2b is immune to length extension attacks, and as such does not require any
              specific precautions, such as using the HMAC algorithm.
            <br/>
            
            </summary>
            <param name="hash_size">Length of <paramref name="hash"/>, in bytes. Must be between
                  1 and 64. Anything below 32 is discouraged when using Blake2b as a
                  general-purpose hash function; anything below 16 is discouraged when using
                  Blake2b as a message authentication code.</param>
            <param name="key">Some secret key. One cannot predict the final hash without it. May be
                  NULL if
                  <paramref name="key_size"/> is 0, in which case no key is
                  used. Keys can be used to create a message authentication code (MAC). Use
                  <see cref="M:Monocypher.Monocypher.crypto_verify16(Monocypher.Monocypher.Byte16@,Monocypher.Monocypher.Byte16@)"/>,
                  <see cref="M:Monocypher.Monocypher.crypto_verify32(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>, or
                  <see cref="M:Monocypher.Monocypher.crypto_verify64(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte64@)"/> to compare MACs
                  created this way. Choose the size of the hash accordingly. Users may want
                  to wipe the key with <see cref="M:Monocypher.Monocypher.crypto_wipe(System.IntPtr,Monocypher.Monocypher.size_t)"/>
                  once they are done with it.</param>
            <param name="ctx">See Monocypher manual for more details.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_argon2i(System.IntPtr,System.UInt32,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr,System.UInt32,System.IntPtr,System.UInt32)">
            <summary>
            
            Argon2i is a resource intensive password key derivation scheme optimised for the
              typical x86-like processor. It runs in constant time with respect to the
              contents of the password.
            <br/>
            
            Typical applications are password checking (for online services), and key
              derivation (for encryption). Derived keys can be used to encrypt, for example,
              private keys or password databases.
            <br/>
            
            The version provided by Monocypher has no threading support, so the degree of
              parallelism is limited to 1. This is considered good enough for most purposes.
            <br/>
            
            </summary>
            <param name="hash">See Monocypher manual for more details.</param>
            <param name="hash_size">See Monocypher manual for more details.</param>
            <param name="work_area">See Monocypher manual for more details.</param>
            <param name="nb_blocks">See Monocypher manual for more details.</param>
            <param name="nb_iterations">See Monocypher manual for more details.</param>
            <param name="password">See Monocypher manual for more details.</param>
            <param name="password_size">See Monocypher manual for more details.</param>
            <param name="salt">See Monocypher manual for more details.</param>
            <param name="salt_size">See Monocypher manual for more details.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_argon2i(System.Span{System.Byte},System.Span{System.Byte},System.UInt32,System.UInt32,System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte})">
            <summary>
            
            Argon2i is a resource intensive password key derivation scheme optimised for the
              typical x86-like processor. It runs in constant time with respect to the
              contents of the password.
            <br/>
            
            Typical applications are password checking (for online services), and key
              derivation (for encryption). Derived keys can be used to encrypt, for example,
              private keys or password databases.
            <br/>
            
            The version provided by Monocypher has no threading support, so the degree of
              parallelism is limited to 1. This is considered good enough for most purposes.
            <br/>
            
            </summary>
            <param name="hash">See Monocypher manual for more details.</param>
            <param name="work_area">See Monocypher manual for more details.</param>
            <param name="nb_blocks">See Monocypher manual for more details.</param>
            <param name="nb_iterations">See Monocypher manual for more details.</param>
            <param name="password">See Monocypher manual for more details.</param>
            <param name="salt">See Monocypher manual for more details.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_argon2i_general(System.IntPtr,System.UInt32,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr,System.UInt32,System.IntPtr,System.UInt32,System.IntPtr,System.UInt32,System.IntPtr,System.UInt32)">
            <summary>
            
            Argon2i is a resource intensive password key derivation scheme optimised for the
              typical x86-like processor. It runs in constant time with respect to the
              contents of the password.
            <br/>
            
            Typical applications are password checking (for online services), and key
              derivation (for encryption). Derived keys can be used to encrypt, for example,
              private keys or password databases.
            <br/>
            
            The version provided by Monocypher has no threading support, so the degree of
              parallelism is limited to 1. This is considered good enough for most purposes.
            <br/>
            
            </summary>
            <param name="hash">See Monocypher manual for more details.</param>
            <param name="hash_size">See Monocypher manual for more details.</param>
            <param name="work_area">See Monocypher manual for more details.</param>
            <param name="nb_blocks">See Monocypher manual for more details.</param>
            <param name="nb_iterations">See Monocypher manual for more details.</param>
            <param name="password">See Monocypher manual for more details.</param>
            <param name="password_size">See Monocypher manual for more details.</param>
            <param name="salt">See Monocypher manual for more details.</param>
            <param name="salt_size">See Monocypher manual for more details.</param>
            <param name="key">See Monocypher manual for more details.</param>
            <param name="key_size">See Monocypher manual for more details.</param>
            <param name="ad">See Monocypher manual for more details.</param>
            <param name="ad_size">See Monocypher manual for more details.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_argon2i_general(System.Span{System.Byte},System.Span{System.Byte},System.UInt32,System.UInt32,System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte})">
            <summary>
            
            Argon2i is a resource intensive password key derivation scheme optimised for the
              typical x86-like processor. It runs in constant time with respect to the
              contents of the password.
            <br/>
            
            Typical applications are password checking (for online services), and key
              derivation (for encryption). Derived keys can be used to encrypt, for example,
              private keys or password databases.
            <br/>
            
            The version provided by Monocypher has no threading support, so the degree of
              parallelism is limited to 1. This is considered good enough for most purposes.
            <br/>
            
            </summary>
            <param name="hash">See Monocypher manual for more details.</param>
            <param name="work_area">See Monocypher manual for more details.</param>
            <param name="nb_blocks">See Monocypher manual for more details.</param>
            <param name="nb_iterations">See Monocypher manual for more details.</param>
            <param name="password">See Monocypher manual for more details.</param>
            <param name="salt">See Monocypher manual for more details.</param>
            <param name="key">See Monocypher manual for more details.</param>
            <param name="ad">See Monocypher manual for more details.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_key_exchange(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)">
            <summary>
            <see cref="M:Monocypher.Monocypher.crypto_key_exchange(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>() computes a shared key
              with your secret key and their public key.
            <br/>
            <see cref="!:crypto_key_exchange_public_key"/>()
              deterministically computes the public key from a random secret key.
            <br/>
            
            </summary>
            <param name="shared_key">A 32-byte buffer. The shared secret, known only to those who know a relevant secret key
                  (yours or theirs). It is cryptographically random, and suitable for use
                  with the <see cref="M:Monocypher.Monocypher.crypto_lock(Monocypher.Monocypher.Byte16@,System.IntPtr,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte24@,System.IntPtr,Monocypher.Monocypher.size_t)"/> family of
                  functions.</param>
            <param name="your_secret_key">A 32-byte random number, known only to you. See
                  intro(3monocypher) for advice about
                  generating random bytes (use the operating system's random number
                  generator).</param>
            <param name="their_public_key">A 32-byte buffer. The public key of the other party.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_key_exchange(System.Span{System.Byte},System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte})">
            <summary>
            <see cref="M:Monocypher.Monocypher.crypto_key_exchange(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>() computes a shared key
              with your secret key and their public key.
            <br/>
            <see cref="!:crypto_key_exchange_public_key"/>()
              deterministically computes the public key from a random secret key.
            <br/>
            
            </summary>
            <param name="shared_key">A 32-byte buffer. The shared secret, known only to those who know a relevant secret key
                  (yours or theirs). It is cryptographically random, and suitable for use
                  with the <see cref="M:Monocypher.Monocypher.crypto_lock(Monocypher.Monocypher.Byte16@,System.IntPtr,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte24@,System.IntPtr,Monocypher.Monocypher.size_t)"/> family of
                  functions.</param>
            <param name="your_secret_key">A 32-byte random number, known only to you. See
                  intro(3monocypher) for advice about
                  generating random bytes (use the operating system's random number
                  generator).</param>
            <param name="their_public_key">A 32-byte buffer. The public key of the other party.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_sign_public_key(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)">
            <summary>
            <see cref="M:Monocypher.Monocypher.crypto_sign(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,System.IntPtr,Monocypher.Monocypher.size_t)"/>() and
              <see cref="M:Monocypher.Monocypher.crypto_check(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte32@,System.IntPtr,Monocypher.Monocypher.size_t)"/>() provide EdDSA public key
              signatures and verification.
            <br/>
            
            </summary>
            <param name="secret_key">A 32-byte random number, known only to you. See
                  intro(3monocypher) about random number
                  generation (use your operating system's random number generator). Do not
                  use the same private key for both signatures and key exchanges. The public
                  keys are different, and revealing both may leak information.</param>
            <param name="public_key">A 32-byte buffer. The public key, generated from <paramref name="secret_key"/>
                  with <see cref="M:Monocypher.Monocypher.crypto_sign_public_key(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>().</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_sign_public_key(System.Span{System.Byte},System.ReadOnlySpan{System.Byte})">
            <summary>
            <see cref="M:Monocypher.Monocypher.crypto_sign(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,System.IntPtr,Monocypher.Monocypher.size_t)"/>() and
              <see cref="M:Monocypher.Monocypher.crypto_check(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte32@,System.IntPtr,Monocypher.Monocypher.size_t)"/>() provide EdDSA public key
              signatures and verification.
            <br/>
            
            </summary>
            <param name="secret_key">A 32-byte random number, known only to you. See
                  intro(3monocypher) about random number
                  generation (use your operating system's random number generator). Do not
                  use the same private key for both signatures and key exchanges. The public
                  keys are different, and revealing both may leak information.</param>
            <param name="public_key">A 32-byte buffer. The public key, generated from <paramref name="secret_key"/>
                  with <see cref="M:Monocypher.Monocypher.crypto_sign_public_key(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>().</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_sign(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,System.IntPtr,Monocypher.Monocypher.size_t)">
            <summary>
            <see cref="M:Monocypher.Monocypher.crypto_sign(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,System.IntPtr,Monocypher.Monocypher.size_t)"/>() and
              <see cref="M:Monocypher.Monocypher.crypto_check(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte32@,System.IntPtr,Monocypher.Monocypher.size_t)"/>() provide EdDSA public key
              signatures and verification.
            <br/>
            
            </summary>
            <param name="signature">A 64-byte buffer. The signature.</param>
            <param name="secret_key">A 32-byte random number, known only to you. See
                  intro(3monocypher) about random number
                  generation (use your operating system's random number generator). Do not
                  use the same private key for both signatures and key exchanges. The public
                  keys are different, and revealing both may leak information.</param>
            <param name="public_key">A 32-byte buffer. The public key, generated from <paramref name="secret_key"/>
                  with <see cref="M:Monocypher.Monocypher.crypto_sign_public_key(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>().</param>
            <param name="message">Message to sign.</param>
            <param name="message_size">Length of <paramref name="message"/>, in bytes.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_sign(System.Span{System.Byte},System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte})">
            <summary>
            <see cref="M:Monocypher.Monocypher.crypto_sign(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,System.IntPtr,Monocypher.Monocypher.size_t)"/>() and
              <see cref="M:Monocypher.Monocypher.crypto_check(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte32@,System.IntPtr,Monocypher.Monocypher.size_t)"/>() provide EdDSA public key
              signatures and verification.
            <br/>
            
            </summary>
            <param name="signature">A 64-byte buffer. The signature.</param>
            <param name="secret_key">A 32-byte random number, known only to you. See
                  intro(3monocypher) about random number
                  generation (use your operating system's random number generator). Do not
                  use the same private key for both signatures and key exchanges. The public
                  keys are different, and revealing both may leak information.</param>
            <param name="public_key">A 32-byte buffer. The public key, generated from <paramref name="secret_key"/>
                  with <see cref="M:Monocypher.Monocypher.crypto_sign_public_key(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>().</param>
            <param name="message">Message to sign.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_check(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte32@,System.IntPtr,Monocypher.Monocypher.size_t)">
            <summary>
            <see cref="M:Monocypher.Monocypher.crypto_sign(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,System.IntPtr,Monocypher.Monocypher.size_t)"/>() and
              <see cref="M:Monocypher.Monocypher.crypto_check(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte32@,System.IntPtr,Monocypher.Monocypher.size_t)"/>() provide EdDSA public key
              signatures and verification.
            <br/>
            
            </summary>
            <param name="signature">A 64-byte buffer. The signature.</param>
            <param name="public_key">A 32-byte buffer. The public key, generated from <paramref name="secret_key"/>
                  with <see cref="M:Monocypher.Monocypher.crypto_sign_public_key(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>().</param>
            <param name="message">Message to sign.</param>
            <param name="message_size">Length of <paramref name="message"/>, in bytes.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_check(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte})">
            <summary>
            <see cref="M:Monocypher.Monocypher.crypto_sign(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,System.IntPtr,Monocypher.Monocypher.size_t)"/>() and
              <see cref="M:Monocypher.Monocypher.crypto_check(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte32@,System.IntPtr,Monocypher.Monocypher.size_t)"/>() provide EdDSA public key
              signatures and verification.
            <br/>
            
            </summary>
            <param name="signature">A 64-byte buffer. The signature.</param>
            <param name="public_key">A 32-byte buffer. The public key, generated from <paramref name="secret_key"/>
                  with <see cref="M:Monocypher.Monocypher.crypto_sign_public_key(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>().</param>
            <param name="message">Message to sign.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_hchacha20(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte16@)">
            <summary>
            <see cref="M:Monocypher.Monocypher.crypto_hchacha20(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte16@)"/>() provides a
              not-so-cryptographic hash. It may be used for some specific purposes, such as
              X25519 key derivation, or XChacha20 initialisation. If in doubt, do not use
              directly. Use <see cref="M:Monocypher.Monocypher.crypto_blake2b(Monocypher.Monocypher.Byte64@,System.IntPtr,Monocypher.Monocypher.size_t)"/>
              instead.
            <br/>
            
            </summary>
            <param name="key">A 32-byte buffer. A sufficiently random key, such as the output of
                  <see cref="M:Monocypher.Monocypher.crypto_x25519(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>.</param>
            <param name="@out">A 32-byte buffer. See Monocypher manual for more details.</param>
            <param name="@in">A 16-byte buffer. See Monocypher manual for more details.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_hchacha20(System.Span{System.Byte},System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte})">
            <summary>
            <see cref="M:Monocypher.Monocypher.crypto_hchacha20(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte16@)"/>() provides a
              not-so-cryptographic hash. It may be used for some specific purposes, such as
              X25519 key derivation, or XChacha20 initialisation. If in doubt, do not use
              directly. Use <see cref="M:Monocypher.Monocypher.crypto_blake2b(Monocypher.Monocypher.Byte64@,System.IntPtr,Monocypher.Monocypher.size_t)"/>
              instead.
            <br/>
            
            </summary>
            <param name="key">A 32-byte buffer. A sufficiently random key, such as the output of
                  <see cref="M:Monocypher.Monocypher.crypto_x25519(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>.</param>
            <param name="@out">A 32-byte buffer. See Monocypher manual for more details.</param>
            <param name="@in">A 16-byte buffer. See Monocypher manual for more details.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_chacha20(System.IntPtr,System.IntPtr,Monocypher.Monocypher.size_t,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte8@)">
            <summary>
            
            These functions provide an interface for the Chacha20 encryption primitive.
            <br/>
            
            Chacha20 is a low-level primitive. Consider using authenticated encryption,
              implemented by <see cref="M:Monocypher.Monocypher.crypto_lock(Monocypher.Monocypher.Byte16@,System.IntPtr,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte24@,System.IntPtr,Monocypher.Monocypher.size_t)"/>.
            <br/>
            
            </summary>
            <param name="key">A 32-byte secret key.</param>
            <param name="nonce">A 8-byte buffer. An 8-byte or 24-byte number, used only once with any given key. It does
                  not need to be secret or random, but it does have to be unique. Repeating
                  a nonce with the same key reveals the XOR of two different messages, which
                  allows decryption. 24-byte nonces can be selected at random. 8-byte nonces
                  cannot. They are too small, and the same
                  nonce may be selected twice by accident. See
                  intro(3monocypher) for advice about
                  generating random numbers (use the operating system's random number
                  generator).</param>
            <param name="plain_text">The message to encrypt. It is allowed to be
                  NULL, in which case it will be
                  interpreted as an all zero input.
                  <paramref name="cipher_text"/> will then contain the raw
                  Chacha20 stream.</param>
            <param name="cipher_text">The encrypted message.</param>
            <param name="text_size">Length of both <paramref name="plain_text"/> and
                  <paramref name="cipher_text"/>, in bytes.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_chacha20(System.Span{System.Byte},System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte})">
            <summary>
            
            These functions provide an interface for the Chacha20 encryption primitive.
            <br/>
            
            Chacha20 is a low-level primitive. Consider using authenticated encryption,
              implemented by <see cref="M:Monocypher.Monocypher.crypto_lock(Monocypher.Monocypher.Byte16@,System.IntPtr,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte24@,System.IntPtr,Monocypher.Monocypher.size_t)"/>.
            <br/>
            
            </summary>
            <param name="key">A 32-byte secret key.</param>
            <param name="nonce">A 8-byte buffer. An 8-byte or 24-byte number, used only once with any given key. It does
                  not need to be secret or random, but it does have to be unique. Repeating
                  a nonce with the same key reveals the XOR of two different messages, which
                  allows decryption. 24-byte nonces can be selected at random. 8-byte nonces
                  cannot. They are too small, and the same
                  nonce may be selected twice by accident. See
                  intro(3monocypher) for advice about
                  generating random numbers (use the operating system's random number
                  generator).</param>
            <param name="plain_text">The message to encrypt. It is allowed to be
                  NULL, in which case it will be
                  interpreted as an all zero input.
                  <paramref name="cipher_text"/> will then contain the raw
                  Chacha20 stream.</param>
            <param name="cipher_text">The encrypted message.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_xchacha20(System.IntPtr,System.IntPtr,Monocypher.Monocypher.size_t,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte24@)">
            <summary>
            
            These functions provide an interface for the Chacha20 encryption primitive.
            <br/>
            
            Chacha20 is a low-level primitive. Consider using authenticated encryption,
              implemented by <see cref="M:Monocypher.Monocypher.crypto_lock(Monocypher.Monocypher.Byte16@,System.IntPtr,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte24@,System.IntPtr,Monocypher.Monocypher.size_t)"/>.
            <br/>
            
            </summary>
            <param name="key">A 32-byte secret key.</param>
            <param name="nonce">A 24-byte buffer. An 8-byte or 24-byte number, used only once with any given key. It does
                  not need to be secret or random, but it does have to be unique. Repeating
                  a nonce with the same key reveals the XOR of two different messages, which
                  allows decryption. 24-byte nonces can be selected at random. 8-byte nonces
                  cannot. They are too small, and the same
                  nonce may be selected twice by accident. See
                  intro(3monocypher) for advice about
                  generating random numbers (use the operating system's random number
                  generator).</param>
            <param name="plain_text">The message to encrypt. It is allowed to be
                  NULL, in which case it will be
                  interpreted as an all zero input.
                  <paramref name="cipher_text"/> will then contain the raw
                  Chacha20 stream.</param>
            <param name="cipher_text">The encrypted message.</param>
            <param name="text_size">Length of both <paramref name="plain_text"/> and
                  <paramref name="cipher_text"/>, in bytes.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_xchacha20(System.Span{System.Byte},System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte})">
            <summary>
            
            These functions provide an interface for the Chacha20 encryption primitive.
            <br/>
            
            Chacha20 is a low-level primitive. Consider using authenticated encryption,
              implemented by <see cref="M:Monocypher.Monocypher.crypto_lock(Monocypher.Monocypher.Byte16@,System.IntPtr,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte24@,System.IntPtr,Monocypher.Monocypher.size_t)"/>.
            <br/>
            
            </summary>
            <param name="key">A 32-byte secret key.</param>
            <param name="nonce">A 24-byte buffer. An 8-byte or 24-byte number, used only once with any given key. It does
                  not need to be secret or random, but it does have to be unique. Repeating
                  a nonce with the same key reveals the XOR of two different messages, which
                  allows decryption. 24-byte nonces can be selected at random. 8-byte nonces
                  cannot. They are too small, and the same
                  nonce may be selected twice by accident. See
                  intro(3monocypher) for advice about
                  generating random numbers (use the operating system's random number
                  generator).</param>
            <param name="plain_text">The message to encrypt. It is allowed to be
                  NULL, in which case it will be
                  interpreted as an all zero input.
                  <paramref name="cipher_text"/> will then contain the raw
                  Chacha20 stream.</param>
            <param name="cipher_text">The encrypted message.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_ietf_chacha20(System.IntPtr,System.IntPtr,Monocypher.Monocypher.size_t,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte12@)">
            <summary>
            
            These functions provide an interface for the Chacha20 encryption primitive as
              specified by the IETF in RFC 8439. They are provided strictly for
              compatibility with existing systems or strict standards compliance. New
              programs are strongly encouraged to use
              <see cref="M:Monocypher.Monocypher.crypto_xchacha20(System.Span{System.Byte},System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte})"/> instead.
            <br/>
            
            Chacha20 is a low-level primitive. Consider using authenticated encryption,
              implemented by <see cref="M:Monocypher.Monocypher.crypto_lock(Monocypher.Monocypher.Byte16@,System.IntPtr,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte24@,System.IntPtr,Monocypher.Monocypher.size_t)"/>.
            <br/>
            
            The <see cref="M:Monocypher.Monocypher.crypto_ietf_chacha20(System.IntPtr,System.IntPtr,Monocypher.Monocypher.size_t,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte12@)"/>() and
              <see cref="M:Monocypher.Monocypher.crypto_ietf_chacha20_ctr(System.IntPtr,System.IntPtr,Monocypher.Monocypher.size_t,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte12@,System.UInt32)"/>() functions behave
              the same as <see cref="M:Monocypher.Monocypher.crypto_chacha20(System.Span{System.Byte},System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte})"/> and
              <see cref="M:Monocypher.Monocypher.crypto_chacha20_ctr(System.Span{System.Byte},System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.UInt64)"/>, respectively, but use
              differently-sized nonce and counter values. The nonce encompasses 12 bytes and
              the counter is correspondingly reduced to 4 bytes. The short counter limits a
              single pair of key and nonce to 256 GiB of data. A nonce of 12 bytes is
              just barely too short to be safely chosen at
              random; use a message counter instead. RFC 8439 also permits linear feedback
              shift registers to generate nonces.
            
            </summary>
            <param name="cipher_text">See Monocypher manual for more details.</param>
            <param name="plain_text">See Monocypher manual for more details.</param>
            <param name="text_size">See Monocypher manual for more details.</param>
            <param name="key">A 32-byte buffer. See Monocypher manual for more details.</param>
            <param name="nonce">A 12-byte buffer. See Monocypher manual for more details.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_ietf_chacha20(System.Span{System.Byte},System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte})">
            <summary>
            
            These functions provide an interface for the Chacha20 encryption primitive as
              specified by the IETF in RFC 8439. They are provided strictly for
              compatibility with existing systems or strict standards compliance. New
              programs are strongly encouraged to use
              <see cref="M:Monocypher.Monocypher.crypto_xchacha20(System.Span{System.Byte},System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte})"/> instead.
            <br/>
            
            Chacha20 is a low-level primitive. Consider using authenticated encryption,
              implemented by <see cref="M:Monocypher.Monocypher.crypto_lock(Monocypher.Monocypher.Byte16@,System.IntPtr,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte24@,System.IntPtr,Monocypher.Monocypher.size_t)"/>.
            <br/>
            
            The <see cref="M:Monocypher.Monocypher.crypto_ietf_chacha20(System.IntPtr,System.IntPtr,Monocypher.Monocypher.size_t,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte12@)"/>() and
              <see cref="M:Monocypher.Monocypher.crypto_ietf_chacha20_ctr(System.IntPtr,System.IntPtr,Monocypher.Monocypher.size_t,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte12@,System.UInt32)"/>() functions behave
              the same as <see cref="M:Monocypher.Monocypher.crypto_chacha20(System.Span{System.Byte},System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte})"/> and
              <see cref="M:Monocypher.Monocypher.crypto_chacha20_ctr(System.Span{System.Byte},System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.UInt64)"/>, respectively, but use
              differently-sized nonce and counter values. The nonce encompasses 12 bytes and
              the counter is correspondingly reduced to 4 bytes. The short counter limits a
              single pair of key and nonce to 256 GiB of data. A nonce of 12 bytes is
              just barely too short to be safely chosen at
              random; use a message counter instead. RFC 8439 also permits linear feedback
              shift registers to generate nonces.
            
            </summary>
            <param name="cipher_text">See Monocypher manual for more details.</param>
            <param name="plain_text">See Monocypher manual for more details.</param>
            <param name="key">A 32-byte buffer. See Monocypher manual for more details.</param>
            <param name="nonce">A 12-byte buffer. See Monocypher manual for more details.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_chacha20_ctr(System.IntPtr,System.IntPtr,Monocypher.Monocypher.size_t,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte8@,System.UInt64)">
            <summary>
            
            These functions provide an interface for the Chacha20 encryption primitive.
            <br/>
            
            Chacha20 is a low-level primitive. Consider using authenticated encryption,
              implemented by <see cref="M:Monocypher.Monocypher.crypto_lock(Monocypher.Monocypher.Byte16@,System.IntPtr,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte24@,System.IntPtr,Monocypher.Monocypher.size_t)"/>.
            <br/>
            
            </summary>
            <param name="key">A 32-byte secret key.</param>
            <param name="nonce">A 8-byte buffer. An 8-byte or 24-byte number, used only once with any given key. It does
                  not need to be secret or random, but it does have to be unique. Repeating
                  a nonce with the same key reveals the XOR of two different messages, which
                  allows decryption. 24-byte nonces can be selected at random. 8-byte nonces
                  cannot. They are too small, and the same
                  nonce may be selected twice by accident. See
                  intro(3monocypher) for advice about
                  generating random numbers (use the operating system's random number
                  generator).</param>
            <param name="plain_text">The message to encrypt. It is allowed to be
                  NULL, in which case it will be
                  interpreted as an all zero input.
                  <paramref name="cipher_text"/> will then contain the raw
                  Chacha20 stream.</param>
            <param name="cipher_text">The encrypted message.</param>
            <param name="text_size">Length of both <paramref name="plain_text"/> and
                  <paramref name="cipher_text"/>, in bytes.</param>
            <param name="ctr">The number of 64-byte blocks since the beginning of the stream.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_chacha20_ctr(System.Span{System.Byte},System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.UInt64)">
            <summary>
            
            These functions provide an interface for the Chacha20 encryption primitive.
            <br/>
            
            Chacha20 is a low-level primitive. Consider using authenticated encryption,
              implemented by <see cref="M:Monocypher.Monocypher.crypto_lock(Monocypher.Monocypher.Byte16@,System.IntPtr,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte24@,System.IntPtr,Monocypher.Monocypher.size_t)"/>.
            <br/>
            
            </summary>
            <param name="key">A 32-byte secret key.</param>
            <param name="nonce">A 8-byte buffer. An 8-byte or 24-byte number, used only once with any given key. It does
                  not need to be secret or random, but it does have to be unique. Repeating
                  a nonce with the same key reveals the XOR of two different messages, which
                  allows decryption. 24-byte nonces can be selected at random. 8-byte nonces
                  cannot. They are too small, and the same
                  nonce may be selected twice by accident. See
                  intro(3monocypher) for advice about
                  generating random numbers (use the operating system's random number
                  generator).</param>
            <param name="plain_text">The message to encrypt. It is allowed to be
                  NULL, in which case it will be
                  interpreted as an all zero input.
                  <paramref name="cipher_text"/> will then contain the raw
                  Chacha20 stream.</param>
            <param name="cipher_text">The encrypted message.</param>
            <param name="ctr">The number of 64-byte blocks since the beginning of the stream.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_xchacha20_ctr(System.IntPtr,System.IntPtr,Monocypher.Monocypher.size_t,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte24@,System.UInt64)">
            <summary>
            
            These functions provide an interface for the Chacha20 encryption primitive.
            <br/>
            
            Chacha20 is a low-level primitive. Consider using authenticated encryption,
              implemented by <see cref="M:Monocypher.Monocypher.crypto_lock(Monocypher.Monocypher.Byte16@,System.IntPtr,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte24@,System.IntPtr,Monocypher.Monocypher.size_t)"/>.
            <br/>
            
            </summary>
            <param name="key">A 32-byte secret key.</param>
            <param name="nonce">A 24-byte buffer. An 8-byte or 24-byte number, used only once with any given key. It does
                  not need to be secret or random, but it does have to be unique. Repeating
                  a nonce with the same key reveals the XOR of two different messages, which
                  allows decryption. 24-byte nonces can be selected at random. 8-byte nonces
                  cannot. They are too small, and the same
                  nonce may be selected twice by accident. See
                  intro(3monocypher) for advice about
                  generating random numbers (use the operating system's random number
                  generator).</param>
            <param name="plain_text">The message to encrypt. It is allowed to be
                  NULL, in which case it will be
                  interpreted as an all zero input.
                  <paramref name="cipher_text"/> will then contain the raw
                  Chacha20 stream.</param>
            <param name="cipher_text">The encrypted message.</param>
            <param name="text_size">Length of both <paramref name="plain_text"/> and
                  <paramref name="cipher_text"/>, in bytes.</param>
            <param name="ctr">The number of 64-byte blocks since the beginning of the stream.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_xchacha20_ctr(System.Span{System.Byte},System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.UInt64)">
            <summary>
            
            These functions provide an interface for the Chacha20 encryption primitive.
            <br/>
            
            Chacha20 is a low-level primitive. Consider using authenticated encryption,
              implemented by <see cref="M:Monocypher.Monocypher.crypto_lock(Monocypher.Monocypher.Byte16@,System.IntPtr,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte24@,System.IntPtr,Monocypher.Monocypher.size_t)"/>.
            <br/>
            
            </summary>
            <param name="key">A 32-byte secret key.</param>
            <param name="nonce">A 24-byte buffer. An 8-byte or 24-byte number, used only once with any given key. It does
                  not need to be secret or random, but it does have to be unique. Repeating
                  a nonce with the same key reveals the XOR of two different messages, which
                  allows decryption. 24-byte nonces can be selected at random. 8-byte nonces
                  cannot. They are too small, and the same
                  nonce may be selected twice by accident. See
                  intro(3monocypher) for advice about
                  generating random numbers (use the operating system's random number
                  generator).</param>
            <param name="plain_text">The message to encrypt. It is allowed to be
                  NULL, in which case it will be
                  interpreted as an all zero input.
                  <paramref name="cipher_text"/> will then contain the raw
                  Chacha20 stream.</param>
            <param name="cipher_text">The encrypted message.</param>
            <param name="ctr">The number of 64-byte blocks since the beginning of the stream.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_ietf_chacha20_ctr(System.IntPtr,System.IntPtr,Monocypher.Monocypher.size_t,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte12@,System.UInt32)">
            <summary>
            
            These functions provide an interface for the Chacha20 encryption primitive as
              specified by the IETF in RFC 8439. They are provided strictly for
              compatibility with existing systems or strict standards compliance. New
              programs are strongly encouraged to use
              <see cref="M:Monocypher.Monocypher.crypto_xchacha20(System.Span{System.Byte},System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte})"/> instead.
            <br/>
            
            Chacha20 is a low-level primitive. Consider using authenticated encryption,
              implemented by <see cref="M:Monocypher.Monocypher.crypto_lock(Monocypher.Monocypher.Byte16@,System.IntPtr,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte24@,System.IntPtr,Monocypher.Monocypher.size_t)"/>.
            <br/>
            
            The <see cref="M:Monocypher.Monocypher.crypto_ietf_chacha20(System.IntPtr,System.IntPtr,Monocypher.Monocypher.size_t,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte12@)"/>() and
              <see cref="M:Monocypher.Monocypher.crypto_ietf_chacha20_ctr(System.IntPtr,System.IntPtr,Monocypher.Monocypher.size_t,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte12@,System.UInt32)"/>() functions behave
              the same as <see cref="M:Monocypher.Monocypher.crypto_chacha20(System.Span{System.Byte},System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte})"/> and
              <see cref="M:Monocypher.Monocypher.crypto_chacha20_ctr(System.Span{System.Byte},System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.UInt64)"/>, respectively, but use
              differently-sized nonce and counter values. The nonce encompasses 12 bytes and
              the counter is correspondingly reduced to 4 bytes. The short counter limits a
              single pair of key and nonce to 256 GiB of data. A nonce of 12 bytes is
              just barely too short to be safely chosen at
              random; use a message counter instead. RFC 8439 also permits linear feedback
              shift registers to generate nonces.
            
            </summary>
            <param name="cipher_text">See Monocypher manual for more details.</param>
            <param name="plain_text">See Monocypher manual for more details.</param>
            <param name="text_size">See Monocypher manual for more details.</param>
            <param name="key">A 32-byte buffer. See Monocypher manual for more details.</param>
            <param name="nonce">A 12-byte buffer. See Monocypher manual for more details.</param>
            <param name="ctr">See Monocypher manual for more details.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_ietf_chacha20_ctr(System.Span{System.Byte},System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.UInt32)">
            <summary>
            
            These functions provide an interface for the Chacha20 encryption primitive as
              specified by the IETF in RFC 8439. They are provided strictly for
              compatibility with existing systems or strict standards compliance. New
              programs are strongly encouraged to use
              <see cref="M:Monocypher.Monocypher.crypto_xchacha20(System.Span{System.Byte},System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte})"/> instead.
            <br/>
            
            Chacha20 is a low-level primitive. Consider using authenticated encryption,
              implemented by <see cref="M:Monocypher.Monocypher.crypto_lock(Monocypher.Monocypher.Byte16@,System.IntPtr,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte24@,System.IntPtr,Monocypher.Monocypher.size_t)"/>.
            <br/>
            
            The <see cref="M:Monocypher.Monocypher.crypto_ietf_chacha20(System.IntPtr,System.IntPtr,Monocypher.Monocypher.size_t,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte12@)"/>() and
              <see cref="M:Monocypher.Monocypher.crypto_ietf_chacha20_ctr(System.IntPtr,System.IntPtr,Monocypher.Monocypher.size_t,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte12@,System.UInt32)"/>() functions behave
              the same as <see cref="M:Monocypher.Monocypher.crypto_chacha20(System.Span{System.Byte},System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte})"/> and
              <see cref="M:Monocypher.Monocypher.crypto_chacha20_ctr(System.Span{System.Byte},System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.UInt64)"/>, respectively, but use
              differently-sized nonce and counter values. The nonce encompasses 12 bytes and
              the counter is correspondingly reduced to 4 bytes. The short counter limits a
              single pair of key and nonce to 256 GiB of data. A nonce of 12 bytes is
              just barely too short to be safely chosen at
              random; use a message counter instead. RFC 8439 also permits linear feedback
              shift registers to generate nonces.
            
            </summary>
            <param name="cipher_text">See Monocypher manual for more details.</param>
            <param name="plain_text">See Monocypher manual for more details.</param>
            <param name="key">A 32-byte buffer. See Monocypher manual for more details.</param>
            <param name="nonce">A 12-byte buffer. See Monocypher manual for more details.</param>
            <param name="ctr">See Monocypher manual for more details.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_poly1305(Monocypher.Monocypher.Byte16@,System.IntPtr,Monocypher.Monocypher.size_t,Monocypher.Monocypher.Byte32@)">
            <summary>
            
            Poly1305 is a one-time message authentication code. &#x201C;One-time&#x201D;
              means the authentication key can be used only once.
              This makes Poly1305 easy to misuse. On the other
              hand, Poly1305 is fast, and provably secure if used correctly.
            <br/>
            
            Poly1305 is a low-level primitive. Consider using authenticated encryption,
              implemented by <see cref="M:Monocypher.Monocypher.crypto_lock(Monocypher.Monocypher.Byte16@,System.IntPtr,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte24@,System.IntPtr,Monocypher.Monocypher.size_t)"/>.
            <br/>
            
            </summary>
            <param name="mac">A 16-byte buffer. The authentication code.</param>
            <param name="key">A 32-byte buffer. The secret authentication key. Use only once per message. Do not use the
                  session key to authenticate messages. It should be wiped with
                  <see cref="M:Monocypher.Monocypher.crypto_wipe(System.IntPtr,Monocypher.Monocypher.size_t)"/> after use.</param>
            <param name="message">The message to authenticate. May overlap with the
                  <paramref name="mac"/> argument.</param>
            <param name="message_size">Length of <paramref name="message"/>, in bytes.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_poly1305(System.Span{System.Byte},System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte})">
            <summary>
            
            Poly1305 is a one-time message authentication code. &#x201C;One-time&#x201D;
              means the authentication key can be used only once.
              This makes Poly1305 easy to misuse. On the other
              hand, Poly1305 is fast, and provably secure if used correctly.
            <br/>
            
            Poly1305 is a low-level primitive. Consider using authenticated encryption,
              implemented by <see cref="M:Monocypher.Monocypher.crypto_lock(Monocypher.Monocypher.Byte16@,System.IntPtr,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte24@,System.IntPtr,Monocypher.Monocypher.size_t)"/>.
            <br/>
            
            </summary>
            <param name="mac">A 16-byte buffer. The authentication code.</param>
            <param name="key">A 32-byte buffer. The secret authentication key. Use only once per message. Do not use the
                  session key to authenticate messages. It should be wiped with
                  <see cref="M:Monocypher.Monocypher.crypto_wipe(System.IntPtr,Monocypher.Monocypher.size_t)"/> after use.</param>
            <param name="message">The message to authenticate. May overlap with the
                  <paramref name="mac"/> argument.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_poly1305_init(Monocypher.Monocypher.crypto_poly1305_ctx@,Monocypher.Monocypher.Byte32@)">
            <summary>
            
            Poly1305 is a one-time message authentication code. &#x201C;One-time&#x201D;
              means the authentication key can be used only once.
              This makes Poly1305 easy to misuse. On the other
              hand, Poly1305 is fast, and provably secure if used correctly.
            <br/>
            
            Poly1305 is a low-level primitive. Consider using authenticated encryption,
              implemented by <see cref="M:Monocypher.Monocypher.crypto_lock(Monocypher.Monocypher.Byte16@,System.IntPtr,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte24@,System.IntPtr,Monocypher.Monocypher.size_t)"/>.
            <br/>
            
            </summary>
            <param name="key">A 32-byte buffer. The secret authentication key. Use only once per message. Do not use the
                  session key to authenticate messages. It should be wiped with
                  <see cref="M:Monocypher.Monocypher.crypto_wipe(System.IntPtr,Monocypher.Monocypher.size_t)"/> after use.</param>
            <param name="ctx">See Monocypher manual for more details.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_poly1305_init(Monocypher.Monocypher.crypto_poly1305_ctx@,System.ReadOnlySpan{System.Byte})">
            <summary>
            
            Poly1305 is a one-time message authentication code. &#x201C;One-time&#x201D;
              means the authentication key can be used only once.
              This makes Poly1305 easy to misuse. On the other
              hand, Poly1305 is fast, and provably secure if used correctly.
            <br/>
            
            Poly1305 is a low-level primitive. Consider using authenticated encryption,
              implemented by <see cref="M:Monocypher.Monocypher.crypto_lock(Monocypher.Monocypher.Byte16@,System.IntPtr,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte24@,System.IntPtr,Monocypher.Monocypher.size_t)"/>.
            <br/>
            
            </summary>
            <param name="key">A 32-byte buffer. The secret authentication key. Use only once per message. Do not use the
                  session key to authenticate messages. It should be wiped with
                  <see cref="M:Monocypher.Monocypher.crypto_wipe(System.IntPtr,Monocypher.Monocypher.size_t)"/> after use.</param>
            <param name="ctx">See Monocypher manual for more details.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_poly1305_update(Monocypher.Monocypher.crypto_poly1305_ctx@,System.IntPtr,Monocypher.Monocypher.size_t)">
            <summary>
            
            Poly1305 is a one-time message authentication code. &#x201C;One-time&#x201D;
              means the authentication key can be used only once.
              This makes Poly1305 easy to misuse. On the other
              hand, Poly1305 is fast, and provably secure if used correctly.
            <br/>
            
            Poly1305 is a low-level primitive. Consider using authenticated encryption,
              implemented by <see cref="M:Monocypher.Monocypher.crypto_lock(Monocypher.Monocypher.Byte16@,System.IntPtr,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte24@,System.IntPtr,Monocypher.Monocypher.size_t)"/>.
            <br/>
            
            </summary>
            <param name="message">The message to authenticate. May overlap with the
                  <paramref name="mac"/> argument.</param>
            <param name="message_size">Length of <paramref name="message"/>, in bytes.</param>
            <param name="ctx">See Monocypher manual for more details.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_poly1305_update(Monocypher.Monocypher.crypto_poly1305_ctx@,System.ReadOnlySpan{System.Byte})">
            <summary>
            
            Poly1305 is a one-time message authentication code. &#x201C;One-time&#x201D;
              means the authentication key can be used only once.
              This makes Poly1305 easy to misuse. On the other
              hand, Poly1305 is fast, and provably secure if used correctly.
            <br/>
            
            Poly1305 is a low-level primitive. Consider using authenticated encryption,
              implemented by <see cref="M:Monocypher.Monocypher.crypto_lock(Monocypher.Monocypher.Byte16@,System.IntPtr,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte24@,System.IntPtr,Monocypher.Monocypher.size_t)"/>.
            <br/>
            
            </summary>
            <param name="message">The message to authenticate. May overlap with the
                  <paramref name="mac"/> argument.</param>
            <param name="ctx">See Monocypher manual for more details.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_poly1305_final(Monocypher.Monocypher.crypto_poly1305_ctx@,Monocypher.Monocypher.Byte16@)">
            <summary>
            
            Poly1305 is a one-time message authentication code. &#x201C;One-time&#x201D;
              means the authentication key can be used only once.
              This makes Poly1305 easy to misuse. On the other
              hand, Poly1305 is fast, and provably secure if used correctly.
            <br/>
            
            Poly1305 is a low-level primitive. Consider using authenticated encryption,
              implemented by <see cref="M:Monocypher.Monocypher.crypto_lock(Monocypher.Monocypher.Byte16@,System.IntPtr,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte24@,System.IntPtr,Monocypher.Monocypher.size_t)"/>.
            <br/>
            
            </summary>
            <param name="mac">A 16-byte buffer. The authentication code.</param>
            <param name="ctx">See Monocypher manual for more details.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_poly1305_final(Monocypher.Monocypher.crypto_poly1305_ctx@,System.Span{System.Byte})">
            <summary>
            
            Poly1305 is a one-time message authentication code. &#x201C;One-time&#x201D;
              means the authentication key can be used only once.
              This makes Poly1305 easy to misuse. On the other
              hand, Poly1305 is fast, and provably secure if used correctly.
            <br/>
            
            Poly1305 is a low-level primitive. Consider using authenticated encryption,
              implemented by <see cref="M:Monocypher.Monocypher.crypto_lock(Monocypher.Monocypher.Byte16@,System.IntPtr,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte24@,System.IntPtr,Monocypher.Monocypher.size_t)"/>.
            <br/>
            
            </summary>
            <param name="mac">A 16-byte buffer. The authentication code.</param>
            <param name="ctx">See Monocypher manual for more details.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_x25519_public_key(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)">
            <summary>
            <see cref="M:Monocypher.Monocypher.crypto_x25519(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>() computes a shared secret with
              <paramref name="your_secret_key"/> and
              <paramref name="their_public_key"/>. It is a low-level
              primitive. Use <see cref="M:Monocypher.Monocypher.crypto_key_exchange(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>
              unless you have a specific reason not to.
            <br/>
            <see cref="M:Monocypher.Monocypher.crypto_x25519_public_key(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>() is the same as
              <see cref="!:crypto_key_exchange_public_key"/>. It
              deterministically computes the public key from a random secret key.
            <br/>
            
            </summary>
            <param name="public_key">A 32-byte buffer. See Monocypher manual for more details.</param>
            <param name="secret_key">A 32-byte buffer. See Monocypher manual for more details.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_x25519_public_key(System.Span{System.Byte},System.ReadOnlySpan{System.Byte})">
            <summary>
            <see cref="M:Monocypher.Monocypher.crypto_x25519(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>() computes a shared secret with
              <paramref name="your_secret_key"/> and
              <paramref name="their_public_key"/>. It is a low-level
              primitive. Use <see cref="M:Monocypher.Monocypher.crypto_key_exchange(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>
              unless you have a specific reason not to.
            <br/>
            <see cref="M:Monocypher.Monocypher.crypto_x25519_public_key(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>() is the same as
              <see cref="!:crypto_key_exchange_public_key"/>. It
              deterministically computes the public key from a random secret key.
            <br/>
            
            </summary>
            <param name="public_key">A 32-byte buffer. See Monocypher manual for more details.</param>
            <param name="secret_key">A 32-byte buffer. See Monocypher manual for more details.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_x25519(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)">
            <summary>
            <see cref="M:Monocypher.Monocypher.crypto_x25519(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>() computes a shared secret with
              <paramref name="your_secret_key"/> and
              <paramref name="their_public_key"/>. It is a low-level
              primitive. Use <see cref="M:Monocypher.Monocypher.crypto_key_exchange(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>
              unless you have a specific reason not to.
            <br/>
            <see cref="M:Monocypher.Monocypher.crypto_x25519_public_key(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>() is the same as
              <see cref="!:crypto_key_exchange_public_key"/>. It
              deterministically computes the public key from a random secret key.
            <br/>
            
            </summary>
            <param name="raw_shared_secret">A 32-byte buffer. The shared secret, known only to those who know a relevant secret key
                  (yours or theirs). It is not cryptographically random. Do not use it
                  directly as a key. Hash it with
                  <see cref="M:Monocypher.Monocypher.crypto_hchacha20(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte16@)"/> or
                  <see cref="M:Monocypher.Monocypher.crypto_blake2b(Monocypher.Monocypher.Byte64@,System.IntPtr,Monocypher.Monocypher.size_t)"/> first.</param>
            <param name="your_secret_key">A 32-byte secret random number. See
                  intro(3monocypher) for advice about
                  generating random bytes (use the operating system's random number
                  generator).</param>
            <param name="their_public_key">A 32-byte buffer. The public key of the other party.
                <br/>
            <paramref name="raw_shared_secret"/> and
                  <paramref name="your_secret_key"/> may overlap if your
                  secret is no longer required.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_x25519(System.Span{System.Byte},System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte})">
            <summary>
            <see cref="M:Monocypher.Monocypher.crypto_x25519(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>() computes a shared secret with
              <paramref name="your_secret_key"/> and
              <paramref name="their_public_key"/>. It is a low-level
              primitive. Use <see cref="M:Monocypher.Monocypher.crypto_key_exchange(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>
              unless you have a specific reason not to.
            <br/>
            <see cref="M:Monocypher.Monocypher.crypto_x25519_public_key(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>() is the same as
              <see cref="!:crypto_key_exchange_public_key"/>. It
              deterministically computes the public key from a random secret key.
            <br/>
            
            </summary>
            <param name="raw_shared_secret">A 32-byte buffer. The shared secret, known only to those who know a relevant secret key
                  (yours or theirs). It is not cryptographically random. Do not use it
                  directly as a key. Hash it with
                  <see cref="M:Monocypher.Monocypher.crypto_hchacha20(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte16@)"/> or
                  <see cref="M:Monocypher.Monocypher.crypto_blake2b(Monocypher.Monocypher.Byte64@,System.IntPtr,Monocypher.Monocypher.size_t)"/> first.</param>
            <param name="your_secret_key">A 32-byte secret random number. See
                  intro(3monocypher) for advice about
                  generating random bytes (use the operating system's random number
                  generator).</param>
            <param name="their_public_key">A 32-byte buffer. The public key of the other party.
                <br/>
            <paramref name="raw_shared_secret"/> and
                  <paramref name="your_secret_key"/> may overlap if your
                  secret is no longer required.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_x25519_dirty_small(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)">
            <summary>
            
            These functions are used in public key generation for
              <see cref="M:Monocypher.Monocypher.crypto_curve_to_hidden(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,System.Byte)"/>.
              This is a highly advanced feature; unless you are
              reading this because you were referred here from
              <see cref="M:Monocypher.Monocypher.crypto_curve_to_hidden(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,System.Byte)"/>,
              you likely have no reason to be using these
              functions and are probably looking for
              <see cref="M:Monocypher.Monocypher.crypto_key_exchange(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/> or
              <see cref="M:Monocypher.Monocypher.crypto_x25519(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/> instead. Expect
              elliptic curve jargon on this page.
            <br/>
            
            Both functions generate a Curve25519 public key
              <paramref name="pk"/> from the given secret key
              <paramref name="sk"/>; the public keys are on the
              whole curve, rather than just the main
              prime-order subgroup. Both do the same with different code size and memory
              characteristics: <see cref="M:Monocypher.Monocypher.crypto_x25519_dirty_fast(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>()
              uses multiple large temporary variables and uses functions that are normally
              used internally for <see cref="M:Monocypher.Monocypher.crypto_sign(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,System.IntPtr,Monocypher.Monocypher.size_t)"/>;
              accordingly, it uses both more memory (for the temporary variables) and more
              code size (unless the signing code is already compiled in elsewhere).
              <see cref="M:Monocypher.Monocypher.crypto_x25519_dirty_small(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>() yields the same
              result, but does so using less code and memory at a large performance penalty
              compared to <see cref="M:Monocypher.Monocypher.crypto_x25519_dirty_fast(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>().
            <br/>
            
            The resulting public keys are to be used with
              <see cref="M:Monocypher.Monocypher.crypto_x25519(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/> or
              <see cref="M:Monocypher.Monocypher.crypto_key_exchange(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>, which clear the
              cofactor.
            
            </summary>
            <param name="pk">A 32-byte buffer. See Monocypher manual for more details.</param>
            <param name="sk">A 32-byte buffer. See Monocypher manual for more details.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_x25519_dirty_small(System.Span{System.Byte},System.ReadOnlySpan{System.Byte})">
            <summary>
            
            These functions are used in public key generation for
              <see cref="M:Monocypher.Monocypher.crypto_curve_to_hidden(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,System.Byte)"/>.
              This is a highly advanced feature; unless you are
              reading this because you were referred here from
              <see cref="M:Monocypher.Monocypher.crypto_curve_to_hidden(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,System.Byte)"/>,
              you likely have no reason to be using these
              functions and are probably looking for
              <see cref="M:Monocypher.Monocypher.crypto_key_exchange(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/> or
              <see cref="M:Monocypher.Monocypher.crypto_x25519(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/> instead. Expect
              elliptic curve jargon on this page.
            <br/>
            
            Both functions generate a Curve25519 public key
              <paramref name="pk"/> from the given secret key
              <paramref name="sk"/>; the public keys are on the
              whole curve, rather than just the main
              prime-order subgroup. Both do the same with different code size and memory
              characteristics: <see cref="M:Monocypher.Monocypher.crypto_x25519_dirty_fast(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>()
              uses multiple large temporary variables and uses functions that are normally
              used internally for <see cref="M:Monocypher.Monocypher.crypto_sign(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,System.IntPtr,Monocypher.Monocypher.size_t)"/>;
              accordingly, it uses both more memory (for the temporary variables) and more
              code size (unless the signing code is already compiled in elsewhere).
              <see cref="M:Monocypher.Monocypher.crypto_x25519_dirty_small(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>() yields the same
              result, but does so using less code and memory at a large performance penalty
              compared to <see cref="M:Monocypher.Monocypher.crypto_x25519_dirty_fast(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>().
            <br/>
            
            The resulting public keys are to be used with
              <see cref="M:Monocypher.Monocypher.crypto_x25519(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/> or
              <see cref="M:Monocypher.Monocypher.crypto_key_exchange(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>, which clear the
              cofactor.
            
            </summary>
            <param name="pk">A 32-byte buffer. See Monocypher manual for more details.</param>
            <param name="sk">A 32-byte buffer. See Monocypher manual for more details.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_x25519_dirty_fast(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)">
            <summary>
            
            These functions are used in public key generation for
              <see cref="M:Monocypher.Monocypher.crypto_curve_to_hidden(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,System.Byte)"/>.
              This is a highly advanced feature; unless you are
              reading this because you were referred here from
              <see cref="M:Monocypher.Monocypher.crypto_curve_to_hidden(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,System.Byte)"/>,
              you likely have no reason to be using these
              functions and are probably looking for
              <see cref="M:Monocypher.Monocypher.crypto_key_exchange(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/> or
              <see cref="M:Monocypher.Monocypher.crypto_x25519(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/> instead. Expect
              elliptic curve jargon on this page.
            <br/>
            
            Both functions generate a Curve25519 public key
              <paramref name="pk"/> from the given secret key
              <paramref name="sk"/>; the public keys are on the
              whole curve, rather than just the main
              prime-order subgroup. Both do the same with different code size and memory
              characteristics: <see cref="M:Monocypher.Monocypher.crypto_x25519_dirty_fast(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>()
              uses multiple large temporary variables and uses functions that are normally
              used internally for <see cref="M:Monocypher.Monocypher.crypto_sign(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,System.IntPtr,Monocypher.Monocypher.size_t)"/>;
              accordingly, it uses both more memory (for the temporary variables) and more
              code size (unless the signing code is already compiled in elsewhere).
              <see cref="M:Monocypher.Monocypher.crypto_x25519_dirty_small(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>() yields the same
              result, but does so using less code and memory at a large performance penalty
              compared to <see cref="M:Monocypher.Monocypher.crypto_x25519_dirty_fast(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>().
            <br/>
            
            The resulting public keys are to be used with
              <see cref="M:Monocypher.Monocypher.crypto_x25519(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/> or
              <see cref="M:Monocypher.Monocypher.crypto_key_exchange(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>, which clear the
              cofactor.
            
            </summary>
            <param name="pk">A 32-byte buffer. See Monocypher manual for more details.</param>
            <param name="sk">A 32-byte buffer. See Monocypher manual for more details.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_x25519_dirty_fast(System.Span{System.Byte},System.ReadOnlySpan{System.Byte})">
            <summary>
            
            These functions are used in public key generation for
              <see cref="M:Monocypher.Monocypher.crypto_curve_to_hidden(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,System.Byte)"/>.
              This is a highly advanced feature; unless you are
              reading this because you were referred here from
              <see cref="M:Monocypher.Monocypher.crypto_curve_to_hidden(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,System.Byte)"/>,
              you likely have no reason to be using these
              functions and are probably looking for
              <see cref="M:Monocypher.Monocypher.crypto_key_exchange(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/> or
              <see cref="M:Monocypher.Monocypher.crypto_x25519(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/> instead. Expect
              elliptic curve jargon on this page.
            <br/>
            
            Both functions generate a Curve25519 public key
              <paramref name="pk"/> from the given secret key
              <paramref name="sk"/>; the public keys are on the
              whole curve, rather than just the main
              prime-order subgroup. Both do the same with different code size and memory
              characteristics: <see cref="M:Monocypher.Monocypher.crypto_x25519_dirty_fast(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>()
              uses multiple large temporary variables and uses functions that are normally
              used internally for <see cref="M:Monocypher.Monocypher.crypto_sign(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,System.IntPtr,Monocypher.Monocypher.size_t)"/>;
              accordingly, it uses both more memory (for the temporary variables) and more
              code size (unless the signing code is already compiled in elsewhere).
              <see cref="M:Monocypher.Monocypher.crypto_x25519_dirty_small(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>() yields the same
              result, but does so using less code and memory at a large performance penalty
              compared to <see cref="M:Monocypher.Monocypher.crypto_x25519_dirty_fast(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>().
            <br/>
            
            The resulting public keys are to be used with
              <see cref="M:Monocypher.Monocypher.crypto_x25519(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/> or
              <see cref="M:Monocypher.Monocypher.crypto_key_exchange(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>, which clear the
              cofactor.
            
            </summary>
            <param name="pk">A 32-byte buffer. See Monocypher manual for more details.</param>
            <param name="sk">A 32-byte buffer. See Monocypher manual for more details.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_x25519_inverse(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)">
            <summary>
            
            The <see cref="M:Monocypher.Monocypher.crypto_x25519_inverse(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>() function performs
              scalar multiplication of the multiplicative inverse of a scalar for X25519.
              This is a highly advanced, specialized feature;
              unless you are implementing a protocol that requires this specifically,
              you likely have no reason to be using these
              functions and are probably looking for
              <see cref="M:Monocypher.Monocypher.crypto_key_exchange(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/> or
              <see cref="M:Monocypher.Monocypher.crypto_x25519(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/> instead. Expect
              elliptic curve jargon on this page.
            <br/>
            
            This function is used, for example, with exponential blinding in oblivious
              pseudo-random functions (OPRFs).
            </summary>
            <param name="blind_salt">A 32-byte buffer. The output point.</param>
            <param name="private_key">A 32-byte buffer. The private key (scalar) to use. First, the value is clamped; then the
                  clamped value's multiplicative inverse (modulo the curve order) is
                  determined; the clamped value's multiplicative inverse then has its
                  cofactor cleared, and that final value is then used for scalar
                  multiplication.</param>
            <param name="curve_point">A 32-byte buffer. The curve point on X25519 to multiply with the multiplicative inverse
                  (modulo the curve order) of
                <paramref name="private_key"/>.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_x25519_inverse(System.Span{System.Byte},System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte})">
            <summary>
            
            The <see cref="M:Monocypher.Monocypher.crypto_x25519_inverse(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>() function performs
              scalar multiplication of the multiplicative inverse of a scalar for X25519.
              This is a highly advanced, specialized feature;
              unless you are implementing a protocol that requires this specifically,
              you likely have no reason to be using these
              functions and are probably looking for
              <see cref="M:Monocypher.Monocypher.crypto_key_exchange(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/> or
              <see cref="M:Monocypher.Monocypher.crypto_x25519(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/> instead. Expect
              elliptic curve jargon on this page.
            <br/>
            
            This function is used, for example, with exponential blinding in oblivious
              pseudo-random functions (OPRFs).
            </summary>
            <param name="blind_salt">A 32-byte buffer. The output point.</param>
            <param name="private_key">A 32-byte buffer. The private key (scalar) to use. First, the value is clamped; then the
                  clamped value's multiplicative inverse (modulo the curve order) is
                  determined; the clamped value's multiplicative inverse then has its
                  cofactor cleared, and that final value is then used for scalar
                  multiplication.</param>
            <param name="curve_point">A 32-byte buffer. The curve point on X25519 to multiply with the multiplicative inverse
                  (modulo the curve order) of
                <paramref name="private_key"/>.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_from_eddsa_private(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)">
            <summary>
            
            These functions convert keys for use with
              <see cref="M:Monocypher.Monocypher.crypto_sign(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,System.IntPtr,Monocypher.Monocypher.size_t)"/> (EdDSA with the BLAKE2b
              hash function) to keys for use with
              <see cref="M:Monocypher.Monocypher.crypto_key_exchange(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/> and
              <see cref="M:Monocypher.Monocypher.crypto_x25519(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>. This may be useful in
              some resource-constrained contexts or when no other key is available (for
              example, when retrieving SSH public keys from GitHub and reusing the SSH
              public keys as X25519 public keys).
            <br/>
            
            The <see cref="M:Monocypher.Monocypher.crypto_from_eddsa_private(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>() function
              converts an EdDSA (with BLAKE2b) private key to an X25519 private key. The
              <see cref="M:Monocypher.Monocypher.crypto_from_eddsa_public(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>() function
              converts an EdDSA public key to an X25519 public key.
            <br/>
            
            X25519 key pairs cannot be converted back to EdDSA key pairs. The conversion of
              private keys is specific to EdDSA with BLAKE2b because of the way EdDSA works.
              In particular, this means that the output of
              <see cref="M:Monocypher.Monocypher.crypto_from_eddsa_private(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>() differs from
              <see cref="M:Monocypher.Monocypher.crypto_from_ed25519_private(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/> in the
              optional code. However, the output of
              <see cref="M:Monocypher.Monocypher.crypto_from_eddsa_public(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>() is identical to
              <see cref="!:crypto_from_ed25519_public"/>.
            <br/>
            
            </summary>
            <param name="eddsa">A 32-byte buffer. The signing public key or private key to convert to a X25519 public key or
                  private key, respectively.</param>
            <param name="x25519">A 32-byte buffer. The converted private key or public key.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_from_eddsa_private(System.Span{System.Byte},System.ReadOnlySpan{System.Byte})">
            <summary>
            
            These functions convert keys for use with
              <see cref="M:Monocypher.Monocypher.crypto_sign(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,System.IntPtr,Monocypher.Monocypher.size_t)"/> (EdDSA with the BLAKE2b
              hash function) to keys for use with
              <see cref="M:Monocypher.Monocypher.crypto_key_exchange(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/> and
              <see cref="M:Monocypher.Monocypher.crypto_x25519(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>. This may be useful in
              some resource-constrained contexts or when no other key is available (for
              example, when retrieving SSH public keys from GitHub and reusing the SSH
              public keys as X25519 public keys).
            <br/>
            
            The <see cref="M:Monocypher.Monocypher.crypto_from_eddsa_private(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>() function
              converts an EdDSA (with BLAKE2b) private key to an X25519 private key. The
              <see cref="M:Monocypher.Monocypher.crypto_from_eddsa_public(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>() function
              converts an EdDSA public key to an X25519 public key.
            <br/>
            
            X25519 key pairs cannot be converted back to EdDSA key pairs. The conversion of
              private keys is specific to EdDSA with BLAKE2b because of the way EdDSA works.
              In particular, this means that the output of
              <see cref="M:Monocypher.Monocypher.crypto_from_eddsa_private(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>() differs from
              <see cref="M:Monocypher.Monocypher.crypto_from_ed25519_private(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/> in the
              optional code. However, the output of
              <see cref="M:Monocypher.Monocypher.crypto_from_eddsa_public(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>() is identical to
              <see cref="!:crypto_from_ed25519_public"/>.
            <br/>
            
            </summary>
            <param name="eddsa">A 32-byte buffer. The signing public key or private key to convert to a X25519 public key or
                  private key, respectively.</param>
            <param name="x25519">A 32-byte buffer. The converted private key or public key.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_from_eddsa_public(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)">
            <summary>
            
            These functions convert keys for use with
              <see cref="M:Monocypher.Monocypher.crypto_sign(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,System.IntPtr,Monocypher.Monocypher.size_t)"/> (EdDSA with the BLAKE2b
              hash function) to keys for use with
              <see cref="M:Monocypher.Monocypher.crypto_key_exchange(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/> and
              <see cref="M:Monocypher.Monocypher.crypto_x25519(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>. This may be useful in
              some resource-constrained contexts or when no other key is available (for
              example, when retrieving SSH public keys from GitHub and reusing the SSH
              public keys as X25519 public keys).
            <br/>
            
            The <see cref="M:Monocypher.Monocypher.crypto_from_eddsa_private(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>() function
              converts an EdDSA (with BLAKE2b) private key to an X25519 private key. The
              <see cref="M:Monocypher.Monocypher.crypto_from_eddsa_public(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>() function
              converts an EdDSA public key to an X25519 public key.
            <br/>
            
            X25519 key pairs cannot be converted back to EdDSA key pairs. The conversion of
              private keys is specific to EdDSA with BLAKE2b because of the way EdDSA works.
              In particular, this means that the output of
              <see cref="M:Monocypher.Monocypher.crypto_from_eddsa_private(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>() differs from
              <see cref="M:Monocypher.Monocypher.crypto_from_ed25519_private(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/> in the
              optional code. However, the output of
              <see cref="M:Monocypher.Monocypher.crypto_from_eddsa_public(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>() is identical to
              <see cref="!:crypto_from_ed25519_public"/>.
            <br/>
            
            </summary>
            <param name="eddsa">A 32-byte buffer. The signing public key or private key to convert to a X25519 public key or
                  private key, respectively.</param>
            <param name="x25519">A 32-byte buffer. The converted private key or public key.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_from_eddsa_public(System.Span{System.Byte},System.ReadOnlySpan{System.Byte})">
            <summary>
            
            These functions convert keys for use with
              <see cref="M:Monocypher.Monocypher.crypto_sign(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,System.IntPtr,Monocypher.Monocypher.size_t)"/> (EdDSA with the BLAKE2b
              hash function) to keys for use with
              <see cref="M:Monocypher.Monocypher.crypto_key_exchange(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/> and
              <see cref="M:Monocypher.Monocypher.crypto_x25519(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>. This may be useful in
              some resource-constrained contexts or when no other key is available (for
              example, when retrieving SSH public keys from GitHub and reusing the SSH
              public keys as X25519 public keys).
            <br/>
            
            The <see cref="M:Monocypher.Monocypher.crypto_from_eddsa_private(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>() function
              converts an EdDSA (with BLAKE2b) private key to an X25519 private key. The
              <see cref="M:Monocypher.Monocypher.crypto_from_eddsa_public(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>() function
              converts an EdDSA public key to an X25519 public key.
            <br/>
            
            X25519 key pairs cannot be converted back to EdDSA key pairs. The conversion of
              private keys is specific to EdDSA with BLAKE2b because of the way EdDSA works.
              In particular, this means that the output of
              <see cref="M:Monocypher.Monocypher.crypto_from_eddsa_private(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>() differs from
              <see cref="M:Monocypher.Monocypher.crypto_from_ed25519_private(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/> in the
              optional code. However, the output of
              <see cref="M:Monocypher.Monocypher.crypto_from_eddsa_public(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>() is identical to
              <see cref="!:crypto_from_ed25519_public"/>.
            <br/>
            
            </summary>
            <param name="eddsa">A 32-byte buffer. The signing public key or private key to convert to a X25519 public key or
                  private key, respectively.</param>
            <param name="x25519">A 32-byte buffer. The converted private key or public key.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_sign_init_first_pass(Monocypher.Monocypher.crypto_sign_ctx_abstract@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)">
            <summary>
            
            These functions are variants of
              <see cref="M:Monocypher.Monocypher.crypto_sign(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,System.IntPtr,Monocypher.Monocypher.size_t)"/> and
              <see cref="M:Monocypher.Monocypher.crypto_check(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte32@,System.IntPtr,Monocypher.Monocypher.size_t)"/>. Prefer those simpler
              functions if possible.
            <br/>
            
            </summary>
            <param name="ctx">See Monocypher manual for more details.</param>
            <param name="secret_key">A 32-byte buffer. See Monocypher manual for more details.</param>
            <param name="public_key">A 32-byte buffer. See Monocypher manual for more details.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_sign_init_first_pass(Monocypher.Monocypher.crypto_sign_ctx_abstract@,System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte})">
            <summary>
            
            These functions are variants of
              <see cref="M:Monocypher.Monocypher.crypto_sign(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,System.IntPtr,Monocypher.Monocypher.size_t)"/> and
              <see cref="M:Monocypher.Monocypher.crypto_check(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte32@,System.IntPtr,Monocypher.Monocypher.size_t)"/>. Prefer those simpler
              functions if possible.
            <br/>
            
            </summary>
            <param name="ctx">See Monocypher manual for more details.</param>
            <param name="secret_key">A 32-byte buffer. See Monocypher manual for more details.</param>
            <param name="public_key">A 32-byte buffer. See Monocypher manual for more details.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_sign_update(Monocypher.Monocypher.crypto_sign_ctx_abstract@,System.IntPtr,Monocypher.Monocypher.size_t)">
            <summary>
            
            These functions are variants of
              <see cref="M:Monocypher.Monocypher.crypto_sign(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,System.IntPtr,Monocypher.Monocypher.size_t)"/> and
              <see cref="M:Monocypher.Monocypher.crypto_check(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte32@,System.IntPtr,Monocypher.Monocypher.size_t)"/>. Prefer those simpler
              functions if possible.
            <br/>
            
            </summary>
            <param name="ctx">See Monocypher manual for more details.</param>
            <param name="message">See Monocypher manual for more details.</param>
            <param name="message_size">See Monocypher manual for more details.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_sign_update(Monocypher.Monocypher.crypto_sign_ctx_abstract@,System.ReadOnlySpan{System.Byte})">
            <summary>
            
            These functions are variants of
              <see cref="M:Monocypher.Monocypher.crypto_sign(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,System.IntPtr,Monocypher.Monocypher.size_t)"/> and
              <see cref="M:Monocypher.Monocypher.crypto_check(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte32@,System.IntPtr,Monocypher.Monocypher.size_t)"/>. Prefer those simpler
              functions if possible.
            <br/>
            
            </summary>
            <param name="ctx">See Monocypher manual for more details.</param>
            <param name="message">See Monocypher manual for more details.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_sign_init_second_pass(Monocypher.Monocypher.crypto_sign_ctx_abstract@)">
            <summary>
            
            These functions are variants of
              <see cref="M:Monocypher.Monocypher.crypto_sign(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,System.IntPtr,Monocypher.Monocypher.size_t)"/> and
              <see cref="M:Monocypher.Monocypher.crypto_check(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte32@,System.IntPtr,Monocypher.Monocypher.size_t)"/>. Prefer those simpler
              functions if possible.
            <br/>
            
            </summary>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_sign_final(Monocypher.Monocypher.crypto_sign_ctx_abstract@,Monocypher.Monocypher.Byte64@)">
            <summary>
            
            These functions are variants of
              <see cref="M:Monocypher.Monocypher.crypto_sign(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,System.IntPtr,Monocypher.Monocypher.size_t)"/> and
              <see cref="M:Monocypher.Monocypher.crypto_check(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte32@,System.IntPtr,Monocypher.Monocypher.size_t)"/>. Prefer those simpler
              functions if possible.
            <br/>
            
            </summary>
            <param name="ctx">See Monocypher manual for more details.</param>
            <param name="signature">A 64-byte buffer. See Monocypher manual for more details.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_sign_final(Monocypher.Monocypher.crypto_sign_ctx_abstract@,System.Span{System.Byte})">
            <summary>
            
            These functions are variants of
              <see cref="M:Monocypher.Monocypher.crypto_sign(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,System.IntPtr,Monocypher.Monocypher.size_t)"/> and
              <see cref="M:Monocypher.Monocypher.crypto_check(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte32@,System.IntPtr,Monocypher.Monocypher.size_t)"/>. Prefer those simpler
              functions if possible.
            <br/>
            
            </summary>
            <param name="ctx">See Monocypher manual for more details.</param>
            <param name="signature">A 64-byte buffer. See Monocypher manual for more details.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_check_init(Monocypher.Monocypher.crypto_check_ctx_abstract@,Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte32@)">
            <summary>
            
            These functions are variants of
              <see cref="M:Monocypher.Monocypher.crypto_sign(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,System.IntPtr,Monocypher.Monocypher.size_t)"/> and
              <see cref="M:Monocypher.Monocypher.crypto_check(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte32@,System.IntPtr,Monocypher.Monocypher.size_t)"/>. Prefer those simpler
              functions if possible.
            <br/>
            
            </summary>
            <param name="ctx">See Monocypher manual for more details.</param>
            <param name="signature">A 64-byte buffer. See Monocypher manual for more details.</param>
            <param name="public_key">A 32-byte buffer. See Monocypher manual for more details.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_check_init(Monocypher.Monocypher.crypto_check_ctx_abstract@,System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte})">
            <summary>
            
            These functions are variants of
              <see cref="M:Monocypher.Monocypher.crypto_sign(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,System.IntPtr,Monocypher.Monocypher.size_t)"/> and
              <see cref="M:Monocypher.Monocypher.crypto_check(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte32@,System.IntPtr,Monocypher.Monocypher.size_t)"/>. Prefer those simpler
              functions if possible.
            <br/>
            
            </summary>
            <param name="ctx">See Monocypher manual for more details.</param>
            <param name="signature">A 64-byte buffer. See Monocypher manual for more details.</param>
            <param name="public_key">A 32-byte buffer. See Monocypher manual for more details.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_check_update(Monocypher.Monocypher.crypto_check_ctx_abstract@,System.IntPtr,Monocypher.Monocypher.size_t)">
            <summary>
            
            These functions are variants of
              <see cref="M:Monocypher.Monocypher.crypto_sign(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,System.IntPtr,Monocypher.Monocypher.size_t)"/> and
              <see cref="M:Monocypher.Monocypher.crypto_check(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte32@,System.IntPtr,Monocypher.Monocypher.size_t)"/>. Prefer those simpler
              functions if possible.
            <br/>
            
            </summary>
            <param name="ctx">See Monocypher manual for more details.</param>
            <param name="message">See Monocypher manual for more details.</param>
            <param name="message_size">See Monocypher manual for more details.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_check_update(Monocypher.Monocypher.crypto_check_ctx_abstract@,System.ReadOnlySpan{System.Byte})">
            <summary>
            
            These functions are variants of
              <see cref="M:Monocypher.Monocypher.crypto_sign(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,System.IntPtr,Monocypher.Monocypher.size_t)"/> and
              <see cref="M:Monocypher.Monocypher.crypto_check(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte32@,System.IntPtr,Monocypher.Monocypher.size_t)"/>. Prefer those simpler
              functions if possible.
            <br/>
            
            </summary>
            <param name="ctx">See Monocypher manual for more details.</param>
            <param name="message">See Monocypher manual for more details.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_check_final(Monocypher.Monocypher.crypto_check_ctx_abstract@)">
            <summary>
            
            These functions are variants of
              <see cref="M:Monocypher.Monocypher.crypto_sign(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,System.IntPtr,Monocypher.Monocypher.size_t)"/> and
              <see cref="M:Monocypher.Monocypher.crypto_check(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte32@,System.IntPtr,Monocypher.Monocypher.size_t)"/>. Prefer those simpler
              functions if possible.
            <br/>
            
            </summary>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_sign_public_key_custom_hash(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.crypto_sign_vtable@)">
            <summary>
            
            These functions are variants of the
              <see cref="M:Monocypher.Monocypher.crypto_sign_init_first_pass(Monocypher.Monocypher.crypto_sign_ctx_abstract@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/> family
              of functions: They provide the ability to replace the EdDSA hash function with
              any user-provided hash function.
            <br/>
            This is a highly advanced feature. Interoperability
              of public key signatures with other cryptographic libraries can normally be
              achieved by using
              <see cref="M:Monocypher.Monocypher.crypto_ed25519_sign(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,System.IntPtr,Monocypher.Monocypher.size_t)"/> or
              <see cref="M:Monocypher.Monocypher.crypto_ed25519_sign_init_first_pass(Monocypher.Monocypher.crypto_sign_ctx_abstract@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>
              already. This interface is exposed only for completeness and to handle special
              situations (e.g. to use the hash function of the future winner of the NIST
              lightweight crypto competition on a device with highly constrained resources
              or taking advantage of hardware support for cryptographic hash functions).
              Whenever possible, these functions should be avoided.
            <br/>
            
            To make available a custom hash algorithm for use with these functions, a
              crypto_sign_vtable structure must be
              provided. It is defined as:
            <br/>
            <pre>
            <code class="language-c">
            typedef struct { 
                void (*hash)(uint8_t hash[64], const uint8_t *message, 
                             size_t message_size); 
                void (*init  )(void *ctx); 
                void (*update)(void *ctx, const uint8_t *message, 
                               size_t message_size); 
                void (*final )(void *ctx, uint8_t hash[64]); 
                size_t ctx_size; 
            } crypto_sign_vtable;
            </code>
            </pre>
            <br/>
            
            The context argument to the functions shall be referred to as &#x201C;outer
              signing context&#x201D;. The outer signing context must contain a
              crypto_sign_ctx_abstract as
              its first member. Other than that, the outer
              signing context may be defined freely. Logically, it is required to contain
              some kind of hash context as well, else it cannot work as a custom hash
              function.
            <br/>
            
            Because the calling code cannot know the real type of the outer signing context,
              it is cast to void * when calling the hash
              functions in the vtable, but the <paramref name="ctx"/> argument
              to the functions in the vtable is always guaranteed to be the outer signing
              context.
            <br/>
            
            The hash functions must not fail. If they somehow can fail, they have no way to
              propagate its error status, and thus the only ways to handle errors are to
              either assume an error never occurs (if reasonable), or to induce a crash in
              the code when an error occurs.
            <br/>
            
            The fields of crypto_sign_vtable are:
            <dl>
            <dt>
            <paramref name="hash"/>
            </dt>
            <dd>
            Function that computes a 64-byte hash for a given message and writes the
                  computed hash to <paramref name="hash"/>. The output length
                  must be exactly 64 bytes. This will normally
                  be constructed using the functions that provide the
                  <paramref name="init"/>,
                  <paramref name="update"/> and
                  <paramref name="final"/> members.
            </dd>
            <dt>
            <paramref name="init"/>
            </dt>
            <dd>
            Function that initialises the hash context of an outer signing
                context.
            </dd>
            <dt>
            <paramref name="update"/>
            </dt>
            <dd>
            Function that updates the hash context of an outer signing context. It
                  must be able to handle message sizes of at least 32 bytes.
            </dd>
            <dt>
            <paramref name="final"/>
            </dt>
            <dd>
            Function that finalises the hash context of an outer signing context and
                  writes the computed hash to <paramref name="hash"/>. The
                  output length must be exactly 64 bytes. This
                  function should wipe the hash context with
                  <see cref="M:Monocypher.Monocypher.crypto_wipe(System.IntPtr,Monocypher.Monocypher.size_t)"/> if it contains
                  pointers to objects outside the outer signing context. Monocypher takes
                  care of wiping the outer signing context.
            </dd>
            <dt>
            <paramref name="ctx_size"/>
            </dt>
            <dd>
            The size of the outer signing context as determined by
                  sizeof().
            </dd>
            
            </dl>
            <br/>
            
            The functions indicated in the
              crypto_sign_vtable must be thread-safe if any
              of Monocypher's signing functions are accessed from multiple threads.
            <br/>
            
            After calling
              <see cref="M:Monocypher.Monocypher.crypto_sign_init_first_pass_custom_hash(Monocypher.Monocypher.crypto_sign_ctx_abstract@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.crypto_sign_vtable@)"/>()
              or <see cref="M:Monocypher.Monocypher.crypto_check_init_custom_hash(Monocypher.Monocypher.crypto_check_ctx_abstract@,Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.crypto_sign_vtable@)"/>(), the
              <see cref="M:Monocypher.Monocypher.crypto_sign_update(Monocypher.Monocypher.crypto_sign_ctx_abstract@,System.IntPtr,Monocypher.Monocypher.size_t)"/>,
              <see cref="M:Monocypher.Monocypher.crypto_sign_final(Monocypher.Monocypher.crypto_sign_ctx_abstract@,Monocypher.Monocypher.Byte64@)"/>,
              <see cref="M:Monocypher.Monocypher.crypto_sign_init_second_pass(Monocypher.Monocypher.crypto_sign_ctx_abstract@)"/>,
              <see cref="M:Monocypher.Monocypher.crypto_check_update(Monocypher.Monocypher.crypto_check_ctx_abstract@,System.IntPtr,Monocypher.Monocypher.size_t)"/>, and
              <see cref="M:Monocypher.Monocypher.crypto_check_final(Monocypher.Monocypher.crypto_check_ctx_abstract@)"/> functions can be
              used as usual. They will call into the hash vtable as required. The same
              security considerations and semantics apply.
            
            </summary>
            <param name="public_key">A 32-byte buffer. See Monocypher manual for more details.</param>
            <param name="secret_key">A 32-byte buffer. See Monocypher manual for more details.</param>
            <param name="hash">See Monocypher manual for more details.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_sign_public_key_custom_hash(System.Span{System.Byte},System.ReadOnlySpan{System.Byte},Monocypher.Monocypher.crypto_sign_vtable@)">
            <summary>
            
            These functions are variants of the
              <see cref="M:Monocypher.Monocypher.crypto_sign_init_first_pass(Monocypher.Monocypher.crypto_sign_ctx_abstract@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/> family
              of functions: They provide the ability to replace the EdDSA hash function with
              any user-provided hash function.
            <br/>
            This is a highly advanced feature. Interoperability
              of public key signatures with other cryptographic libraries can normally be
              achieved by using
              <see cref="M:Monocypher.Monocypher.crypto_ed25519_sign(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,System.IntPtr,Monocypher.Monocypher.size_t)"/> or
              <see cref="M:Monocypher.Monocypher.crypto_ed25519_sign_init_first_pass(Monocypher.Monocypher.crypto_sign_ctx_abstract@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>
              already. This interface is exposed only for completeness and to handle special
              situations (e.g. to use the hash function of the future winner of the NIST
              lightweight crypto competition on a device with highly constrained resources
              or taking advantage of hardware support for cryptographic hash functions).
              Whenever possible, these functions should be avoided.
            <br/>
            
            To make available a custom hash algorithm for use with these functions, a
              crypto_sign_vtable structure must be
              provided. It is defined as:
            <br/>
            <pre>
            <code class="language-c">
            typedef struct { 
                void (*hash)(uint8_t hash[64], const uint8_t *message, 
                             size_t message_size); 
                void (*init  )(void *ctx); 
                void (*update)(void *ctx, const uint8_t *message, 
                               size_t message_size); 
                void (*final )(void *ctx, uint8_t hash[64]); 
                size_t ctx_size; 
            } crypto_sign_vtable;
            </code>
            </pre>
            <br/>
            
            The context argument to the functions shall be referred to as &#x201C;outer
              signing context&#x201D;. The outer signing context must contain a
              crypto_sign_ctx_abstract as
              its first member. Other than that, the outer
              signing context may be defined freely. Logically, it is required to contain
              some kind of hash context as well, else it cannot work as a custom hash
              function.
            <br/>
            
            Because the calling code cannot know the real type of the outer signing context,
              it is cast to void * when calling the hash
              functions in the vtable, but the <paramref name="ctx"/> argument
              to the functions in the vtable is always guaranteed to be the outer signing
              context.
            <br/>
            
            The hash functions must not fail. If they somehow can fail, they have no way to
              propagate its error status, and thus the only ways to handle errors are to
              either assume an error never occurs (if reasonable), or to induce a crash in
              the code when an error occurs.
            <br/>
            
            The fields of crypto_sign_vtable are:
            <dl>
            <dt>
            <paramref name="hash"/>
            </dt>
            <dd>
            Function that computes a 64-byte hash for a given message and writes the
                  computed hash to <paramref name="hash"/>. The output length
                  must be exactly 64 bytes. This will normally
                  be constructed using the functions that provide the
                  <paramref name="init"/>,
                  <paramref name="update"/> and
                  <paramref name="final"/> members.
            </dd>
            <dt>
            <paramref name="init"/>
            </dt>
            <dd>
            Function that initialises the hash context of an outer signing
                context.
            </dd>
            <dt>
            <paramref name="update"/>
            </dt>
            <dd>
            Function that updates the hash context of an outer signing context. It
                  must be able to handle message sizes of at least 32 bytes.
            </dd>
            <dt>
            <paramref name="final"/>
            </dt>
            <dd>
            Function that finalises the hash context of an outer signing context and
                  writes the computed hash to <paramref name="hash"/>. The
                  output length must be exactly 64 bytes. This
                  function should wipe the hash context with
                  <see cref="M:Monocypher.Monocypher.crypto_wipe(System.IntPtr,Monocypher.Monocypher.size_t)"/> if it contains
                  pointers to objects outside the outer signing context. Monocypher takes
                  care of wiping the outer signing context.
            </dd>
            <dt>
            <paramref name="ctx_size"/>
            </dt>
            <dd>
            The size of the outer signing context as determined by
                  sizeof().
            </dd>
            
            </dl>
            <br/>
            
            The functions indicated in the
              crypto_sign_vtable must be thread-safe if any
              of Monocypher's signing functions are accessed from multiple threads.
            <br/>
            
            After calling
              <see cref="M:Monocypher.Monocypher.crypto_sign_init_first_pass_custom_hash(Monocypher.Monocypher.crypto_sign_ctx_abstract@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.crypto_sign_vtable@)"/>()
              or <see cref="M:Monocypher.Monocypher.crypto_check_init_custom_hash(Monocypher.Monocypher.crypto_check_ctx_abstract@,Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.crypto_sign_vtable@)"/>(), the
              <see cref="M:Monocypher.Monocypher.crypto_sign_update(Monocypher.Monocypher.crypto_sign_ctx_abstract@,System.IntPtr,Monocypher.Monocypher.size_t)"/>,
              <see cref="M:Monocypher.Monocypher.crypto_sign_final(Monocypher.Monocypher.crypto_sign_ctx_abstract@,Monocypher.Monocypher.Byte64@)"/>,
              <see cref="M:Monocypher.Monocypher.crypto_sign_init_second_pass(Monocypher.Monocypher.crypto_sign_ctx_abstract@)"/>,
              <see cref="M:Monocypher.Monocypher.crypto_check_update(Monocypher.Monocypher.crypto_check_ctx_abstract@,System.IntPtr,Monocypher.Monocypher.size_t)"/>, and
              <see cref="M:Monocypher.Monocypher.crypto_check_final(Monocypher.Monocypher.crypto_check_ctx_abstract@)"/> functions can be
              used as usual. They will call into the hash vtable as required. The same
              security considerations and semantics apply.
            
            </summary>
            <param name="public_key">A 32-byte buffer. See Monocypher manual for more details.</param>
            <param name="secret_key">A 32-byte buffer. See Monocypher manual for more details.</param>
            <param name="hash">See Monocypher manual for more details.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_sign_init_first_pass_custom_hash(Monocypher.Monocypher.crypto_sign_ctx_abstract@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.crypto_sign_vtable@)">
            <summary>
            
            These functions are variants of the
              <see cref="M:Monocypher.Monocypher.crypto_sign_init_first_pass(Monocypher.Monocypher.crypto_sign_ctx_abstract@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/> family
              of functions: They provide the ability to replace the EdDSA hash function with
              any user-provided hash function.
            <br/>
            This is a highly advanced feature. Interoperability
              of public key signatures with other cryptographic libraries can normally be
              achieved by using
              <see cref="M:Monocypher.Monocypher.crypto_ed25519_sign(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,System.IntPtr,Monocypher.Monocypher.size_t)"/> or
              <see cref="M:Monocypher.Monocypher.crypto_ed25519_sign_init_first_pass(Monocypher.Monocypher.crypto_sign_ctx_abstract@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>
              already. This interface is exposed only for completeness and to handle special
              situations (e.g. to use the hash function of the future winner of the NIST
              lightweight crypto competition on a device with highly constrained resources
              or taking advantage of hardware support for cryptographic hash functions).
              Whenever possible, these functions should be avoided.
            <br/>
            
            To make available a custom hash algorithm for use with these functions, a
              crypto_sign_vtable structure must be
              provided. It is defined as:
            <br/>
            <pre>
            <code class="language-c">
            typedef struct { 
                void (*hash)(uint8_t hash[64], const uint8_t *message, 
                             size_t message_size); 
                void (*init  )(void *ctx); 
                void (*update)(void *ctx, const uint8_t *message, 
                               size_t message_size); 
                void (*final )(void *ctx, uint8_t hash[64]); 
                size_t ctx_size; 
            } crypto_sign_vtable;
            </code>
            </pre>
            <br/>
            
            The context argument to the functions shall be referred to as &#x201C;outer
              signing context&#x201D;. The outer signing context must contain a
              crypto_sign_ctx_abstract as
              its first member. Other than that, the outer
              signing context may be defined freely. Logically, it is required to contain
              some kind of hash context as well, else it cannot work as a custom hash
              function.
            <br/>
            
            Because the calling code cannot know the real type of the outer signing context,
              it is cast to void * when calling the hash
              functions in the vtable, but the <paramref name="ctx"/> argument
              to the functions in the vtable is always guaranteed to be the outer signing
              context.
            <br/>
            
            The hash functions must not fail. If they somehow can fail, they have no way to
              propagate its error status, and thus the only ways to handle errors are to
              either assume an error never occurs (if reasonable), or to induce a crash in
              the code when an error occurs.
            <br/>
            
            The fields of crypto_sign_vtable are:
            <dl>
            <dt>
            <paramref name="hash"/>
            </dt>
            <dd>
            Function that computes a 64-byte hash for a given message and writes the
                  computed hash to <paramref name="hash"/>. The output length
                  must be exactly 64 bytes. This will normally
                  be constructed using the functions that provide the
                  <paramref name="init"/>,
                  <paramref name="update"/> and
                  <paramref name="final"/> members.
            </dd>
            <dt>
            <paramref name="init"/>
            </dt>
            <dd>
            Function that initialises the hash context of an outer signing
                context.
            </dd>
            <dt>
            <paramref name="update"/>
            </dt>
            <dd>
            Function that updates the hash context of an outer signing context. It
                  must be able to handle message sizes of at least 32 bytes.
            </dd>
            <dt>
            <paramref name="final"/>
            </dt>
            <dd>
            Function that finalises the hash context of an outer signing context and
                  writes the computed hash to <paramref name="hash"/>. The
                  output length must be exactly 64 bytes. This
                  function should wipe the hash context with
                  <see cref="M:Monocypher.Monocypher.crypto_wipe(System.IntPtr,Monocypher.Monocypher.size_t)"/> if it contains
                  pointers to objects outside the outer signing context. Monocypher takes
                  care of wiping the outer signing context.
            </dd>
            <dt>
            <paramref name="ctx_size"/>
            </dt>
            <dd>
            The size of the outer signing context as determined by
                  sizeof().
            </dd>
            
            </dl>
            <br/>
            
            The functions indicated in the
              crypto_sign_vtable must be thread-safe if any
              of Monocypher's signing functions are accessed from multiple threads.
            <br/>
            
            After calling
              <see cref="M:Monocypher.Monocypher.crypto_sign_init_first_pass_custom_hash(Monocypher.Monocypher.crypto_sign_ctx_abstract@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.crypto_sign_vtable@)"/>()
              or <see cref="M:Monocypher.Monocypher.crypto_check_init_custom_hash(Monocypher.Monocypher.crypto_check_ctx_abstract@,Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.crypto_sign_vtable@)"/>(), the
              <see cref="M:Monocypher.Monocypher.crypto_sign_update(Monocypher.Monocypher.crypto_sign_ctx_abstract@,System.IntPtr,Monocypher.Monocypher.size_t)"/>,
              <see cref="M:Monocypher.Monocypher.crypto_sign_final(Monocypher.Monocypher.crypto_sign_ctx_abstract@,Monocypher.Monocypher.Byte64@)"/>,
              <see cref="M:Monocypher.Monocypher.crypto_sign_init_second_pass(Monocypher.Monocypher.crypto_sign_ctx_abstract@)"/>,
              <see cref="M:Monocypher.Monocypher.crypto_check_update(Monocypher.Monocypher.crypto_check_ctx_abstract@,System.IntPtr,Monocypher.Monocypher.size_t)"/>, and
              <see cref="M:Monocypher.Monocypher.crypto_check_final(Monocypher.Monocypher.crypto_check_ctx_abstract@)"/> functions can be
              used as usual. They will call into the hash vtable as required. The same
              security considerations and semantics apply.
            
            </summary>
            <param name="ctx">See Monocypher manual for more details.</param>
            <param name="secret_key">A 32-byte buffer. See Monocypher manual for more details.</param>
            <param name="public_key">A 32-byte buffer. See Monocypher manual for more details.</param>
            <param name="hash">See Monocypher manual for more details.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_sign_init_first_pass_custom_hash(Monocypher.Monocypher.crypto_sign_ctx_abstract@,System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},Monocypher.Monocypher.crypto_sign_vtable@)">
            <summary>
            
            These functions are variants of the
              <see cref="M:Monocypher.Monocypher.crypto_sign_init_first_pass(Monocypher.Monocypher.crypto_sign_ctx_abstract@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/> family
              of functions: They provide the ability to replace the EdDSA hash function with
              any user-provided hash function.
            <br/>
            This is a highly advanced feature. Interoperability
              of public key signatures with other cryptographic libraries can normally be
              achieved by using
              <see cref="M:Monocypher.Monocypher.crypto_ed25519_sign(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,System.IntPtr,Monocypher.Monocypher.size_t)"/> or
              <see cref="M:Monocypher.Monocypher.crypto_ed25519_sign_init_first_pass(Monocypher.Monocypher.crypto_sign_ctx_abstract@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>
              already. This interface is exposed only for completeness and to handle special
              situations (e.g. to use the hash function of the future winner of the NIST
              lightweight crypto competition on a device with highly constrained resources
              or taking advantage of hardware support for cryptographic hash functions).
              Whenever possible, these functions should be avoided.
            <br/>
            
            To make available a custom hash algorithm for use with these functions, a
              crypto_sign_vtable structure must be
              provided. It is defined as:
            <br/>
            <pre>
            <code class="language-c">
            typedef struct { 
                void (*hash)(uint8_t hash[64], const uint8_t *message, 
                             size_t message_size); 
                void (*init  )(void *ctx); 
                void (*update)(void *ctx, const uint8_t *message, 
                               size_t message_size); 
                void (*final )(void *ctx, uint8_t hash[64]); 
                size_t ctx_size; 
            } crypto_sign_vtable;
            </code>
            </pre>
            <br/>
            
            The context argument to the functions shall be referred to as &#x201C;outer
              signing context&#x201D;. The outer signing context must contain a
              crypto_sign_ctx_abstract as
              its first member. Other than that, the outer
              signing context may be defined freely. Logically, it is required to contain
              some kind of hash context as well, else it cannot work as a custom hash
              function.
            <br/>
            
            Because the calling code cannot know the real type of the outer signing context,
              it is cast to void * when calling the hash
              functions in the vtable, but the <paramref name="ctx"/> argument
              to the functions in the vtable is always guaranteed to be the outer signing
              context.
            <br/>
            
            The hash functions must not fail. If they somehow can fail, they have no way to
              propagate its error status, and thus the only ways to handle errors are to
              either assume an error never occurs (if reasonable), or to induce a crash in
              the code when an error occurs.
            <br/>
            
            The fields of crypto_sign_vtable are:
            <dl>
            <dt>
            <paramref name="hash"/>
            </dt>
            <dd>
            Function that computes a 64-byte hash for a given message and writes the
                  computed hash to <paramref name="hash"/>. The output length
                  must be exactly 64 bytes. This will normally
                  be constructed using the functions that provide the
                  <paramref name="init"/>,
                  <paramref name="update"/> and
                  <paramref name="final"/> members.
            </dd>
            <dt>
            <paramref name="init"/>
            </dt>
            <dd>
            Function that initialises the hash context of an outer signing
                context.
            </dd>
            <dt>
            <paramref name="update"/>
            </dt>
            <dd>
            Function that updates the hash context of an outer signing context. It
                  must be able to handle message sizes of at least 32 bytes.
            </dd>
            <dt>
            <paramref name="final"/>
            </dt>
            <dd>
            Function that finalises the hash context of an outer signing context and
                  writes the computed hash to <paramref name="hash"/>. The
                  output length must be exactly 64 bytes. This
                  function should wipe the hash context with
                  <see cref="M:Monocypher.Monocypher.crypto_wipe(System.IntPtr,Monocypher.Monocypher.size_t)"/> if it contains
                  pointers to objects outside the outer signing context. Monocypher takes
                  care of wiping the outer signing context.
            </dd>
            <dt>
            <paramref name="ctx_size"/>
            </dt>
            <dd>
            The size of the outer signing context as determined by
                  sizeof().
            </dd>
            
            </dl>
            <br/>
            
            The functions indicated in the
              crypto_sign_vtable must be thread-safe if any
              of Monocypher's signing functions are accessed from multiple threads.
            <br/>
            
            After calling
              <see cref="M:Monocypher.Monocypher.crypto_sign_init_first_pass_custom_hash(Monocypher.Monocypher.crypto_sign_ctx_abstract@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.crypto_sign_vtable@)"/>()
              or <see cref="M:Monocypher.Monocypher.crypto_check_init_custom_hash(Monocypher.Monocypher.crypto_check_ctx_abstract@,Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.crypto_sign_vtable@)"/>(), the
              <see cref="M:Monocypher.Monocypher.crypto_sign_update(Monocypher.Monocypher.crypto_sign_ctx_abstract@,System.IntPtr,Monocypher.Monocypher.size_t)"/>,
              <see cref="M:Monocypher.Monocypher.crypto_sign_final(Monocypher.Monocypher.crypto_sign_ctx_abstract@,Monocypher.Monocypher.Byte64@)"/>,
              <see cref="M:Monocypher.Monocypher.crypto_sign_init_second_pass(Monocypher.Monocypher.crypto_sign_ctx_abstract@)"/>,
              <see cref="M:Monocypher.Monocypher.crypto_check_update(Monocypher.Monocypher.crypto_check_ctx_abstract@,System.IntPtr,Monocypher.Monocypher.size_t)"/>, and
              <see cref="M:Monocypher.Monocypher.crypto_check_final(Monocypher.Monocypher.crypto_check_ctx_abstract@)"/> functions can be
              used as usual. They will call into the hash vtable as required. The same
              security considerations and semantics apply.
            
            </summary>
            <param name="ctx">See Monocypher manual for more details.</param>
            <param name="secret_key">A 32-byte buffer. See Monocypher manual for more details.</param>
            <param name="public_key">A 32-byte buffer. See Monocypher manual for more details.</param>
            <param name="hash">See Monocypher manual for more details.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_check_init_custom_hash(Monocypher.Monocypher.crypto_check_ctx_abstract@,Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.crypto_sign_vtable@)">
            <summary>
            
            These functions are variants of the
              <see cref="M:Monocypher.Monocypher.crypto_sign_init_first_pass(Monocypher.Monocypher.crypto_sign_ctx_abstract@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/> family
              of functions: They provide the ability to replace the EdDSA hash function with
              any user-provided hash function.
            <br/>
            This is a highly advanced feature. Interoperability
              of public key signatures with other cryptographic libraries can normally be
              achieved by using
              <see cref="M:Monocypher.Monocypher.crypto_ed25519_sign(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,System.IntPtr,Monocypher.Monocypher.size_t)"/> or
              <see cref="M:Monocypher.Monocypher.crypto_ed25519_sign_init_first_pass(Monocypher.Monocypher.crypto_sign_ctx_abstract@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>
              already. This interface is exposed only for completeness and to handle special
              situations (e.g. to use the hash function of the future winner of the NIST
              lightweight crypto competition on a device with highly constrained resources
              or taking advantage of hardware support for cryptographic hash functions).
              Whenever possible, these functions should be avoided.
            <br/>
            
            To make available a custom hash algorithm for use with these functions, a
              crypto_sign_vtable structure must be
              provided. It is defined as:
            <br/>
            <pre>
            <code class="language-c">
            typedef struct { 
                void (*hash)(uint8_t hash[64], const uint8_t *message, 
                             size_t message_size); 
                void (*init  )(void *ctx); 
                void (*update)(void *ctx, const uint8_t *message, 
                               size_t message_size); 
                void (*final )(void *ctx, uint8_t hash[64]); 
                size_t ctx_size; 
            } crypto_sign_vtable;
            </code>
            </pre>
            <br/>
            
            The context argument to the functions shall be referred to as &#x201C;outer
              signing context&#x201D;. The outer signing context must contain a
              crypto_sign_ctx_abstract as
              its first member. Other than that, the outer
              signing context may be defined freely. Logically, it is required to contain
              some kind of hash context as well, else it cannot work as a custom hash
              function.
            <br/>
            
            Because the calling code cannot know the real type of the outer signing context,
              it is cast to void * when calling the hash
              functions in the vtable, but the <paramref name="ctx"/> argument
              to the functions in the vtable is always guaranteed to be the outer signing
              context.
            <br/>
            
            The hash functions must not fail. If they somehow can fail, they have no way to
              propagate its error status, and thus the only ways to handle errors are to
              either assume an error never occurs (if reasonable), or to induce a crash in
              the code when an error occurs.
            <br/>
            
            The fields of crypto_sign_vtable are:
            <dl>
            <dt>
            <paramref name="hash"/>
            </dt>
            <dd>
            Function that computes a 64-byte hash for a given message and writes the
                  computed hash to <paramref name="hash"/>. The output length
                  must be exactly 64 bytes. This will normally
                  be constructed using the functions that provide the
                  <paramref name="init"/>,
                  <paramref name="update"/> and
                  <paramref name="final"/> members.
            </dd>
            <dt>
            <paramref name="init"/>
            </dt>
            <dd>
            Function that initialises the hash context of an outer signing
                context.
            </dd>
            <dt>
            <paramref name="update"/>
            </dt>
            <dd>
            Function that updates the hash context of an outer signing context. It
                  must be able to handle message sizes of at least 32 bytes.
            </dd>
            <dt>
            <paramref name="final"/>
            </dt>
            <dd>
            Function that finalises the hash context of an outer signing context and
                  writes the computed hash to <paramref name="hash"/>. The
                  output length must be exactly 64 bytes. This
                  function should wipe the hash context with
                  <see cref="M:Monocypher.Monocypher.crypto_wipe(System.IntPtr,Monocypher.Monocypher.size_t)"/> if it contains
                  pointers to objects outside the outer signing context. Monocypher takes
                  care of wiping the outer signing context.
            </dd>
            <dt>
            <paramref name="ctx_size"/>
            </dt>
            <dd>
            The size of the outer signing context as determined by
                  sizeof().
            </dd>
            
            </dl>
            <br/>
            
            The functions indicated in the
              crypto_sign_vtable must be thread-safe if any
              of Monocypher's signing functions are accessed from multiple threads.
            <br/>
            
            After calling
              <see cref="M:Monocypher.Monocypher.crypto_sign_init_first_pass_custom_hash(Monocypher.Monocypher.crypto_sign_ctx_abstract@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.crypto_sign_vtable@)"/>()
              or <see cref="M:Monocypher.Monocypher.crypto_check_init_custom_hash(Monocypher.Monocypher.crypto_check_ctx_abstract@,Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.crypto_sign_vtable@)"/>(), the
              <see cref="M:Monocypher.Monocypher.crypto_sign_update(Monocypher.Monocypher.crypto_sign_ctx_abstract@,System.IntPtr,Monocypher.Monocypher.size_t)"/>,
              <see cref="M:Monocypher.Monocypher.crypto_sign_final(Monocypher.Monocypher.crypto_sign_ctx_abstract@,Monocypher.Monocypher.Byte64@)"/>,
              <see cref="M:Monocypher.Monocypher.crypto_sign_init_second_pass(Monocypher.Monocypher.crypto_sign_ctx_abstract@)"/>,
              <see cref="M:Monocypher.Monocypher.crypto_check_update(Monocypher.Monocypher.crypto_check_ctx_abstract@,System.IntPtr,Monocypher.Monocypher.size_t)"/>, and
              <see cref="M:Monocypher.Monocypher.crypto_check_final(Monocypher.Monocypher.crypto_check_ctx_abstract@)"/> functions can be
              used as usual. They will call into the hash vtable as required. The same
              security considerations and semantics apply.
            
            </summary>
            <param name="ctx">See Monocypher manual for more details.</param>
            <param name="signature">A 64-byte buffer. See Monocypher manual for more details.</param>
            <param name="public_key">A 32-byte buffer. See Monocypher manual for more details.</param>
            <param name="hash">See Monocypher manual for more details.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_check_init_custom_hash(Monocypher.Monocypher.crypto_check_ctx_abstract@,System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},Monocypher.Monocypher.crypto_sign_vtable@)">
            <summary>
            
            These functions are variants of the
              <see cref="M:Monocypher.Monocypher.crypto_sign_init_first_pass(Monocypher.Monocypher.crypto_sign_ctx_abstract@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/> family
              of functions: They provide the ability to replace the EdDSA hash function with
              any user-provided hash function.
            <br/>
            This is a highly advanced feature. Interoperability
              of public key signatures with other cryptographic libraries can normally be
              achieved by using
              <see cref="M:Monocypher.Monocypher.crypto_ed25519_sign(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,System.IntPtr,Monocypher.Monocypher.size_t)"/> or
              <see cref="M:Monocypher.Monocypher.crypto_ed25519_sign_init_first_pass(Monocypher.Monocypher.crypto_sign_ctx_abstract@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>
              already. This interface is exposed only for completeness and to handle special
              situations (e.g. to use the hash function of the future winner of the NIST
              lightweight crypto competition on a device with highly constrained resources
              or taking advantage of hardware support for cryptographic hash functions).
              Whenever possible, these functions should be avoided.
            <br/>
            
            To make available a custom hash algorithm for use with these functions, a
              crypto_sign_vtable structure must be
              provided. It is defined as:
            <br/>
            <pre>
            <code class="language-c">
            typedef struct { 
                void (*hash)(uint8_t hash[64], const uint8_t *message, 
                             size_t message_size); 
                void (*init  )(void *ctx); 
                void (*update)(void *ctx, const uint8_t *message, 
                               size_t message_size); 
                void (*final )(void *ctx, uint8_t hash[64]); 
                size_t ctx_size; 
            } crypto_sign_vtable;
            </code>
            </pre>
            <br/>
            
            The context argument to the functions shall be referred to as &#x201C;outer
              signing context&#x201D;. The outer signing context must contain a
              crypto_sign_ctx_abstract as
              its first member. Other than that, the outer
              signing context may be defined freely. Logically, it is required to contain
              some kind of hash context as well, else it cannot work as a custom hash
              function.
            <br/>
            
            Because the calling code cannot know the real type of the outer signing context,
              it is cast to void * when calling the hash
              functions in the vtable, but the <paramref name="ctx"/> argument
              to the functions in the vtable is always guaranteed to be the outer signing
              context.
            <br/>
            
            The hash functions must not fail. If they somehow can fail, they have no way to
              propagate its error status, and thus the only ways to handle errors are to
              either assume an error never occurs (if reasonable), or to induce a crash in
              the code when an error occurs.
            <br/>
            
            The fields of crypto_sign_vtable are:
            <dl>
            <dt>
            <paramref name="hash"/>
            </dt>
            <dd>
            Function that computes a 64-byte hash for a given message and writes the
                  computed hash to <paramref name="hash"/>. The output length
                  must be exactly 64 bytes. This will normally
                  be constructed using the functions that provide the
                  <paramref name="init"/>,
                  <paramref name="update"/> and
                  <paramref name="final"/> members.
            </dd>
            <dt>
            <paramref name="init"/>
            </dt>
            <dd>
            Function that initialises the hash context of an outer signing
                context.
            </dd>
            <dt>
            <paramref name="update"/>
            </dt>
            <dd>
            Function that updates the hash context of an outer signing context. It
                  must be able to handle message sizes of at least 32 bytes.
            </dd>
            <dt>
            <paramref name="final"/>
            </dt>
            <dd>
            Function that finalises the hash context of an outer signing context and
                  writes the computed hash to <paramref name="hash"/>. The
                  output length must be exactly 64 bytes. This
                  function should wipe the hash context with
                  <see cref="M:Monocypher.Monocypher.crypto_wipe(System.IntPtr,Monocypher.Monocypher.size_t)"/> if it contains
                  pointers to objects outside the outer signing context. Monocypher takes
                  care of wiping the outer signing context.
            </dd>
            <dt>
            <paramref name="ctx_size"/>
            </dt>
            <dd>
            The size of the outer signing context as determined by
                  sizeof().
            </dd>
            
            </dl>
            <br/>
            
            The functions indicated in the
              crypto_sign_vtable must be thread-safe if any
              of Monocypher's signing functions are accessed from multiple threads.
            <br/>
            
            After calling
              <see cref="M:Monocypher.Monocypher.crypto_sign_init_first_pass_custom_hash(Monocypher.Monocypher.crypto_sign_ctx_abstract@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.crypto_sign_vtable@)"/>()
              or <see cref="M:Monocypher.Monocypher.crypto_check_init_custom_hash(Monocypher.Monocypher.crypto_check_ctx_abstract@,Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.crypto_sign_vtable@)"/>(), the
              <see cref="M:Monocypher.Monocypher.crypto_sign_update(Monocypher.Monocypher.crypto_sign_ctx_abstract@,System.IntPtr,Monocypher.Monocypher.size_t)"/>,
              <see cref="M:Monocypher.Monocypher.crypto_sign_final(Monocypher.Monocypher.crypto_sign_ctx_abstract@,Monocypher.Monocypher.Byte64@)"/>,
              <see cref="M:Monocypher.Monocypher.crypto_sign_init_second_pass(Monocypher.Monocypher.crypto_sign_ctx_abstract@)"/>,
              <see cref="M:Monocypher.Monocypher.crypto_check_update(Monocypher.Monocypher.crypto_check_ctx_abstract@,System.IntPtr,Monocypher.Monocypher.size_t)"/>, and
              <see cref="M:Monocypher.Monocypher.crypto_check_final(Monocypher.Monocypher.crypto_check_ctx_abstract@)"/> functions can be
              used as usual. They will call into the hash vtable as required. The same
              security considerations and semantics apply.
            
            </summary>
            <param name="ctx">See Monocypher manual for more details.</param>
            <param name="signature">A 64-byte buffer. See Monocypher manual for more details.</param>
            <param name="public_key">A 32-byte buffer. See Monocypher manual for more details.</param>
            <param name="hash">See Monocypher manual for more details.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_hidden_to_curve(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)">
            <summary>
            
            These functions allow obfuscating X25519 public keys by making them appear
              effectively indistinguishable from random noise. This is of interest for key
              exchange protocols that require indistinguishability from randomness, such as
              padded uniform random blobs (PURBs). They are intended for ephemeral
              (short-lived, possibly just one-time) X25519 keys, not for long-term public
              keys. After an initial key exchange involving hidden keys, subsequent key
              exchange messages should be encrypted instead; see, for example, the Noise
              protocol. This is an advanced feature &#x2013;
              unless you are implementing an protocol that requires indistinguishability of
              all communications from random noise, consider
              <see cref="!:crypto_key_exchange_public_key"/>
              instead.
            <br/>
            
            For understanding what these functions do, it is important to note that a
              &#x201C;public key&#x201D; in this context refers to a
              point on Curve25519. This also means that these
              functions are not compatible with
              <see cref="M:Monocypher.Monocypher.crypto_sign(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,System.IntPtr,Monocypher.Monocypher.size_t)"/> and related functions.
            <br/>
            <see cref="M:Monocypher.Monocypher.crypto_curve_to_hidden(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,System.Byte)"/>() takes a public key
              <paramref name="curve"/> and a
              <paramref name="tweak"/>, hiding the public key it so that it is
              effectively indistinguishable from random noise. Note that only
              <see cref="M:Monocypher.Monocypher.crypto_x25519_dirty_fast(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/> or
              <see cref="M:Monocypher.Monocypher.crypto_x25519_dirty_small(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/> can
              generate a suitable public key; the
              <see cref="M:Monocypher.Monocypher.crypto_x25519(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/> function is
              insufficient. The <paramref name="tweak"/> must be chosen at
              random. Even then, this operation may fail: Not
              all curve points are capable of being hidden. In this case,
              <see cref="M:Monocypher.Monocypher.crypto_curve_to_hidden(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,System.Byte)"/>() must be tried
              again with a new key pair; the <paramref name="tweak"/> does not
              need to be changed. On average, two attempts are needed. Once a suitable
              public key has been found,
              <see cref="M:Monocypher.Monocypher.crypto_curve_to_hidden(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,System.Byte)"/>() always succeeds
              for it. Given the same values for <paramref name="tweak"/> and
              <paramref name="curve"/>,
              <see cref="M:Monocypher.Monocypher.crypto_curve_to_hidden(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,System.Byte)"/>() yields the same
              output value <paramref name="hidden"/>.
            <br/>
            <see cref="M:Monocypher.Monocypher.crypto_hidden_to_curve(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>() performs the inverse
              operation: It decodes a hidden point to a curve point on Curve25519.
            <br/>
            <see cref="M:Monocypher.Monocypher.crypto_hidden_key_pair(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>() is a convenience
              function that generates a secret key and its corresponding public key, which
              is effectively indistinguishable from random noise, from a random seed.
              The execution time of this function is
              unpredictable because it may take many failures until a key pair could be
              generated successfully.
              <see cref="M:Monocypher.Monocypher.crypto_hidden_key_pair(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>() uses
              <see cref="M:Monocypher.Monocypher.crypto_x25519_dirty_fast(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/> internally;
              if code size is an important concern, its functionality can be replicated with
              <see cref="M:Monocypher.Monocypher.crypto_x25519_dirty_small(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/> instead.
            <br/>
            
            </summary>
            <param name="curve">A 32-byte buffer. A point on the curve, which is a Curve25519 public key generated with
                  either <see cref="M:Monocypher.Monocypher.crypto_x25519_dirty_fast(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>
                  or
                <see cref="M:Monocypher.Monocypher.crypto_x25519_dirty_small(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>.</param>
            <param name="hidden">A 32-byte buffer. The hidden encoding of a point on the curve which is effectively
                  indistinguishable from random.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_hidden_to_curve(System.Span{System.Byte},System.ReadOnlySpan{System.Byte})">
            <summary>
            
            These functions allow obfuscating X25519 public keys by making them appear
              effectively indistinguishable from random noise. This is of interest for key
              exchange protocols that require indistinguishability from randomness, such as
              padded uniform random blobs (PURBs). They are intended for ephemeral
              (short-lived, possibly just one-time) X25519 keys, not for long-term public
              keys. After an initial key exchange involving hidden keys, subsequent key
              exchange messages should be encrypted instead; see, for example, the Noise
              protocol. This is an advanced feature &#x2013;
              unless you are implementing an protocol that requires indistinguishability of
              all communications from random noise, consider
              <see cref="!:crypto_key_exchange_public_key"/>
              instead.
            <br/>
            
            For understanding what these functions do, it is important to note that a
              &#x201C;public key&#x201D; in this context refers to a
              point on Curve25519. This also means that these
              functions are not compatible with
              <see cref="M:Monocypher.Monocypher.crypto_sign(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,System.IntPtr,Monocypher.Monocypher.size_t)"/> and related functions.
            <br/>
            <see cref="M:Monocypher.Monocypher.crypto_curve_to_hidden(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,System.Byte)"/>() takes a public key
              <paramref name="curve"/> and a
              <paramref name="tweak"/>, hiding the public key it so that it is
              effectively indistinguishable from random noise. Note that only
              <see cref="M:Monocypher.Monocypher.crypto_x25519_dirty_fast(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/> or
              <see cref="M:Monocypher.Monocypher.crypto_x25519_dirty_small(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/> can
              generate a suitable public key; the
              <see cref="M:Monocypher.Monocypher.crypto_x25519(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/> function is
              insufficient. The <paramref name="tweak"/> must be chosen at
              random. Even then, this operation may fail: Not
              all curve points are capable of being hidden. In this case,
              <see cref="M:Monocypher.Monocypher.crypto_curve_to_hidden(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,System.Byte)"/>() must be tried
              again with a new key pair; the <paramref name="tweak"/> does not
              need to be changed. On average, two attempts are needed. Once a suitable
              public key has been found,
              <see cref="M:Monocypher.Monocypher.crypto_curve_to_hidden(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,System.Byte)"/>() always succeeds
              for it. Given the same values for <paramref name="tweak"/> and
              <paramref name="curve"/>,
              <see cref="M:Monocypher.Monocypher.crypto_curve_to_hidden(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,System.Byte)"/>() yields the same
              output value <paramref name="hidden"/>.
            <br/>
            <see cref="M:Monocypher.Monocypher.crypto_hidden_to_curve(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>() performs the inverse
              operation: It decodes a hidden point to a curve point on Curve25519.
            <br/>
            <see cref="M:Monocypher.Monocypher.crypto_hidden_key_pair(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>() is a convenience
              function that generates a secret key and its corresponding public key, which
              is effectively indistinguishable from random noise, from a random seed.
              The execution time of this function is
              unpredictable because it may take many failures until a key pair could be
              generated successfully.
              <see cref="M:Monocypher.Monocypher.crypto_hidden_key_pair(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>() uses
              <see cref="M:Monocypher.Monocypher.crypto_x25519_dirty_fast(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/> internally;
              if code size is an important concern, its functionality can be replicated with
              <see cref="M:Monocypher.Monocypher.crypto_x25519_dirty_small(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/> instead.
            <br/>
            
            </summary>
            <param name="curve">A 32-byte buffer. A point on the curve, which is a Curve25519 public key generated with
                  either <see cref="M:Monocypher.Monocypher.crypto_x25519_dirty_fast(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>
                  or
                <see cref="M:Monocypher.Monocypher.crypto_x25519_dirty_small(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>.</param>
            <param name="hidden">A 32-byte buffer. The hidden encoding of a point on the curve which is effectively
                  indistinguishable from random.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_curve_to_hidden(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,System.Byte)">
            <summary>
            
            These functions allow obfuscating X25519 public keys by making them appear
              effectively indistinguishable from random noise. This is of interest for key
              exchange protocols that require indistinguishability from randomness, such as
              padded uniform random blobs (PURBs). They are intended for ephemeral
              (short-lived, possibly just one-time) X25519 keys, not for long-term public
              keys. After an initial key exchange involving hidden keys, subsequent key
              exchange messages should be encrypted instead; see, for example, the Noise
              protocol. This is an advanced feature &#x2013;
              unless you are implementing an protocol that requires indistinguishability of
              all communications from random noise, consider
              <see cref="!:crypto_key_exchange_public_key"/>
              instead.
            <br/>
            
            For understanding what these functions do, it is important to note that a
              &#x201C;public key&#x201D; in this context refers to a
              point on Curve25519. This also means that these
              functions are not compatible with
              <see cref="M:Monocypher.Monocypher.crypto_sign(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,System.IntPtr,Monocypher.Monocypher.size_t)"/> and related functions.
            <br/>
            <see cref="M:Monocypher.Monocypher.crypto_curve_to_hidden(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,System.Byte)"/>() takes a public key
              <paramref name="curve"/> and a
              <paramref name="tweak"/>, hiding the public key it so that it is
              effectively indistinguishable from random noise. Note that only
              <see cref="M:Monocypher.Monocypher.crypto_x25519_dirty_fast(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/> or
              <see cref="M:Monocypher.Monocypher.crypto_x25519_dirty_small(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/> can
              generate a suitable public key; the
              <see cref="M:Monocypher.Monocypher.crypto_x25519(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/> function is
              insufficient. The <paramref name="tweak"/> must be chosen at
              random. Even then, this operation may fail: Not
              all curve points are capable of being hidden. In this case,
              <see cref="M:Monocypher.Monocypher.crypto_curve_to_hidden(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,System.Byte)"/>() must be tried
              again with a new key pair; the <paramref name="tweak"/> does not
              need to be changed. On average, two attempts are needed. Once a suitable
              public key has been found,
              <see cref="M:Monocypher.Monocypher.crypto_curve_to_hidden(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,System.Byte)"/>() always succeeds
              for it. Given the same values for <paramref name="tweak"/> and
              <paramref name="curve"/>,
              <see cref="M:Monocypher.Monocypher.crypto_curve_to_hidden(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,System.Byte)"/>() yields the same
              output value <paramref name="hidden"/>.
            <br/>
            <see cref="M:Monocypher.Monocypher.crypto_hidden_to_curve(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>() performs the inverse
              operation: It decodes a hidden point to a curve point on Curve25519.
            <br/>
            <see cref="M:Monocypher.Monocypher.crypto_hidden_key_pair(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>() is a convenience
              function that generates a secret key and its corresponding public key, which
              is effectively indistinguishable from random noise, from a random seed.
              The execution time of this function is
              unpredictable because it may take many failures until a key pair could be
              generated successfully.
              <see cref="M:Monocypher.Monocypher.crypto_hidden_key_pair(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>() uses
              <see cref="M:Monocypher.Monocypher.crypto_x25519_dirty_fast(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/> internally;
              if code size is an important concern, its functionality can be replicated with
              <see cref="M:Monocypher.Monocypher.crypto_x25519_dirty_small(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/> instead.
            <br/>
            
            </summary>
            <param name="curve">A 32-byte buffer. A point on the curve, which is a Curve25519 public key generated with
                  either <see cref="M:Monocypher.Monocypher.crypto_x25519_dirty_fast(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>
                  or
                <see cref="M:Monocypher.Monocypher.crypto_x25519_dirty_small(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>.</param>
            <param name="hidden">A 32-byte buffer. The hidden encoding of a point on the curve which is effectively
                  indistinguishable from random.</param>
            <param name="tweak">A 1-byte random number, which influences the final output of
                  <see cref="M:Monocypher.Monocypher.crypto_curve_to_hidden(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,System.Byte)"/>().</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_curve_to_hidden(System.Span{System.Byte},System.ReadOnlySpan{System.Byte},System.Byte)">
            <summary>
            
            These functions allow obfuscating X25519 public keys by making them appear
              effectively indistinguishable from random noise. This is of interest for key
              exchange protocols that require indistinguishability from randomness, such as
              padded uniform random blobs (PURBs). They are intended for ephemeral
              (short-lived, possibly just one-time) X25519 keys, not for long-term public
              keys. After an initial key exchange involving hidden keys, subsequent key
              exchange messages should be encrypted instead; see, for example, the Noise
              protocol. This is an advanced feature &#x2013;
              unless you are implementing an protocol that requires indistinguishability of
              all communications from random noise, consider
              <see cref="!:crypto_key_exchange_public_key"/>
              instead.
            <br/>
            
            For understanding what these functions do, it is important to note that a
              &#x201C;public key&#x201D; in this context refers to a
              point on Curve25519. This also means that these
              functions are not compatible with
              <see cref="M:Monocypher.Monocypher.crypto_sign(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,System.IntPtr,Monocypher.Monocypher.size_t)"/> and related functions.
            <br/>
            <see cref="M:Monocypher.Monocypher.crypto_curve_to_hidden(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,System.Byte)"/>() takes a public key
              <paramref name="curve"/> and a
              <paramref name="tweak"/>, hiding the public key it so that it is
              effectively indistinguishable from random noise. Note that only
              <see cref="M:Monocypher.Monocypher.crypto_x25519_dirty_fast(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/> or
              <see cref="M:Monocypher.Monocypher.crypto_x25519_dirty_small(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/> can
              generate a suitable public key; the
              <see cref="M:Monocypher.Monocypher.crypto_x25519(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/> function is
              insufficient. The <paramref name="tweak"/> must be chosen at
              random. Even then, this operation may fail: Not
              all curve points are capable of being hidden. In this case,
              <see cref="M:Monocypher.Monocypher.crypto_curve_to_hidden(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,System.Byte)"/>() must be tried
              again with a new key pair; the <paramref name="tweak"/> does not
              need to be changed. On average, two attempts are needed. Once a suitable
              public key has been found,
              <see cref="M:Monocypher.Monocypher.crypto_curve_to_hidden(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,System.Byte)"/>() always succeeds
              for it. Given the same values for <paramref name="tweak"/> and
              <paramref name="curve"/>,
              <see cref="M:Monocypher.Monocypher.crypto_curve_to_hidden(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,System.Byte)"/>() yields the same
              output value <paramref name="hidden"/>.
            <br/>
            <see cref="M:Monocypher.Monocypher.crypto_hidden_to_curve(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>() performs the inverse
              operation: It decodes a hidden point to a curve point on Curve25519.
            <br/>
            <see cref="M:Monocypher.Monocypher.crypto_hidden_key_pair(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>() is a convenience
              function that generates a secret key and its corresponding public key, which
              is effectively indistinguishable from random noise, from a random seed.
              The execution time of this function is
              unpredictable because it may take many failures until a key pair could be
              generated successfully.
              <see cref="M:Monocypher.Monocypher.crypto_hidden_key_pair(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>() uses
              <see cref="M:Monocypher.Monocypher.crypto_x25519_dirty_fast(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/> internally;
              if code size is an important concern, its functionality can be replicated with
              <see cref="M:Monocypher.Monocypher.crypto_x25519_dirty_small(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/> instead.
            <br/>
            
            </summary>
            <param name="curve">A 32-byte buffer. A point on the curve, which is a Curve25519 public key generated with
                  either <see cref="M:Monocypher.Monocypher.crypto_x25519_dirty_fast(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>
                  or
                <see cref="M:Monocypher.Monocypher.crypto_x25519_dirty_small(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>.</param>
            <param name="hidden">A 32-byte buffer. The hidden encoding of a point on the curve which is effectively
                  indistinguishable from random.</param>
            <param name="tweak">A 1-byte random number, which influences the final output of
                  <see cref="M:Monocypher.Monocypher.crypto_curve_to_hidden(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,System.Byte)"/>().</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_hidden_key_pair(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)">
            <summary>
            
            These functions allow obfuscating X25519 public keys by making them appear
              effectively indistinguishable from random noise. This is of interest for key
              exchange protocols that require indistinguishability from randomness, such as
              padded uniform random blobs (PURBs). They are intended for ephemeral
              (short-lived, possibly just one-time) X25519 keys, not for long-term public
              keys. After an initial key exchange involving hidden keys, subsequent key
              exchange messages should be encrypted instead; see, for example, the Noise
              protocol. This is an advanced feature &#x2013;
              unless you are implementing an protocol that requires indistinguishability of
              all communications from random noise, consider
              <see cref="!:crypto_key_exchange_public_key"/>
              instead.
            <br/>
            
            For understanding what these functions do, it is important to note that a
              &#x201C;public key&#x201D; in this context refers to a
              point on Curve25519. This also means that these
              functions are not compatible with
              <see cref="M:Monocypher.Monocypher.crypto_sign(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,System.IntPtr,Monocypher.Monocypher.size_t)"/> and related functions.
            <br/>
            <see cref="M:Monocypher.Monocypher.crypto_curve_to_hidden(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,System.Byte)"/>() takes a public key
              <paramref name="curve"/> and a
              <paramref name="tweak"/>, hiding the public key it so that it is
              effectively indistinguishable from random noise. Note that only
              <see cref="M:Monocypher.Monocypher.crypto_x25519_dirty_fast(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/> or
              <see cref="M:Monocypher.Monocypher.crypto_x25519_dirty_small(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/> can
              generate a suitable public key; the
              <see cref="M:Monocypher.Monocypher.crypto_x25519(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/> function is
              insufficient. The <paramref name="tweak"/> must be chosen at
              random. Even then, this operation may fail: Not
              all curve points are capable of being hidden. In this case,
              <see cref="M:Monocypher.Monocypher.crypto_curve_to_hidden(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,System.Byte)"/>() must be tried
              again with a new key pair; the <paramref name="tweak"/> does not
              need to be changed. On average, two attempts are needed. Once a suitable
              public key has been found,
              <see cref="M:Monocypher.Monocypher.crypto_curve_to_hidden(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,System.Byte)"/>() always succeeds
              for it. Given the same values for <paramref name="tweak"/> and
              <paramref name="curve"/>,
              <see cref="M:Monocypher.Monocypher.crypto_curve_to_hidden(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,System.Byte)"/>() yields the same
              output value <paramref name="hidden"/>.
            <br/>
            <see cref="M:Monocypher.Monocypher.crypto_hidden_to_curve(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>() performs the inverse
              operation: It decodes a hidden point to a curve point on Curve25519.
            <br/>
            <see cref="M:Monocypher.Monocypher.crypto_hidden_key_pair(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>() is a convenience
              function that generates a secret key and its corresponding public key, which
              is effectively indistinguishable from random noise, from a random seed.
              The execution time of this function is
              unpredictable because it may take many failures until a key pair could be
              generated successfully.
              <see cref="M:Monocypher.Monocypher.crypto_hidden_key_pair(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>() uses
              <see cref="M:Monocypher.Monocypher.crypto_x25519_dirty_fast(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/> internally;
              if code size is an important concern, its functionality can be replicated with
              <see cref="M:Monocypher.Monocypher.crypto_x25519_dirty_small(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/> instead.
            <br/>
            
            </summary>
            <param name="hidden">A 32-byte buffer. The hidden encoding of a point on the curve which is effectively
                  indistinguishable from random.</param>
            <param name="secret_key">A 32-byte buffer. The secret key that was generated from the given
                  <paramref name="seed"/>.</param>
            <param name="seed">A 32-byte random number from which to derive a key pair. See
                  intro(3monocypher) for advice about
                  generating random bytes (use the operating system's random number
                  generator). The <paramref name="seed"/> is wiped
                  automatically.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_hidden_key_pair(System.Span{System.Byte},System.Span{System.Byte},System.Span{System.Byte})">
            <summary>
            
            These functions allow obfuscating X25519 public keys by making them appear
              effectively indistinguishable from random noise. This is of interest for key
              exchange protocols that require indistinguishability from randomness, such as
              padded uniform random blobs (PURBs). They are intended for ephemeral
              (short-lived, possibly just one-time) X25519 keys, not for long-term public
              keys. After an initial key exchange involving hidden keys, subsequent key
              exchange messages should be encrypted instead; see, for example, the Noise
              protocol. This is an advanced feature &#x2013;
              unless you are implementing an protocol that requires indistinguishability of
              all communications from random noise, consider
              <see cref="!:crypto_key_exchange_public_key"/>
              instead.
            <br/>
            
            For understanding what these functions do, it is important to note that a
              &#x201C;public key&#x201D; in this context refers to a
              point on Curve25519. This also means that these
              functions are not compatible with
              <see cref="M:Monocypher.Monocypher.crypto_sign(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,System.IntPtr,Monocypher.Monocypher.size_t)"/> and related functions.
            <br/>
            <see cref="M:Monocypher.Monocypher.crypto_curve_to_hidden(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,System.Byte)"/>() takes a public key
              <paramref name="curve"/> and a
              <paramref name="tweak"/>, hiding the public key it so that it is
              effectively indistinguishable from random noise. Note that only
              <see cref="M:Monocypher.Monocypher.crypto_x25519_dirty_fast(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/> or
              <see cref="M:Monocypher.Monocypher.crypto_x25519_dirty_small(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/> can
              generate a suitable public key; the
              <see cref="M:Monocypher.Monocypher.crypto_x25519(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/> function is
              insufficient. The <paramref name="tweak"/> must be chosen at
              random. Even then, this operation may fail: Not
              all curve points are capable of being hidden. In this case,
              <see cref="M:Monocypher.Monocypher.crypto_curve_to_hidden(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,System.Byte)"/>() must be tried
              again with a new key pair; the <paramref name="tweak"/> does not
              need to be changed. On average, two attempts are needed. Once a suitable
              public key has been found,
              <see cref="M:Monocypher.Monocypher.crypto_curve_to_hidden(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,System.Byte)"/>() always succeeds
              for it. Given the same values for <paramref name="tweak"/> and
              <paramref name="curve"/>,
              <see cref="M:Monocypher.Monocypher.crypto_curve_to_hidden(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,System.Byte)"/>() yields the same
              output value <paramref name="hidden"/>.
            <br/>
            <see cref="M:Monocypher.Monocypher.crypto_hidden_to_curve(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>() performs the inverse
              operation: It decodes a hidden point to a curve point on Curve25519.
            <br/>
            <see cref="M:Monocypher.Monocypher.crypto_hidden_key_pair(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>() is a convenience
              function that generates a secret key and its corresponding public key, which
              is effectively indistinguishable from random noise, from a random seed.
              The execution time of this function is
              unpredictable because it may take many failures until a key pair could be
              generated successfully.
              <see cref="M:Monocypher.Monocypher.crypto_hidden_key_pair(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>() uses
              <see cref="M:Monocypher.Monocypher.crypto_x25519_dirty_fast(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/> internally;
              if code size is an important concern, its functionality can be replicated with
              <see cref="M:Monocypher.Monocypher.crypto_x25519_dirty_small(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/> instead.
            <br/>
            
            </summary>
            <param name="hidden">A 32-byte buffer. The hidden encoding of a point on the curve which is effectively
                  indistinguishable from random.</param>
            <param name="secret_key">A 32-byte buffer. The secret key that was generated from the given
                  <paramref name="seed"/>.</param>
            <param name="seed">A 32-byte random number from which to derive a key pair. See
                  intro(3monocypher) for advice about
                  generating random bytes (use the operating system's random number
                  generator). The <paramref name="seed"/> is wiped
                  automatically.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_sha512_init(Monocypher.Monocypher.crypto_sha512_ctx@)">
            <summary>
            
            SHA-512 is a cryptographically secure hash, provided to enable compatibility
              with other cryptographic systems. It is generally recommended to use
              <see cref="M:Monocypher.Monocypher.crypto_blake2b(Monocypher.Monocypher.Byte64@,System.IntPtr,Monocypher.Monocypher.size_t)"/> instead, as it both
              performs faster on x86_64 CPUs and lacks many of the pitfalls of SHA-512.
            <br/>
            
            Note that SHA-512 itself is not suitable for hashing passwords and deriving keys
              from them; use the <see cref="M:Monocypher.Monocypher.crypto_argon2i(System.IntPtr,System.UInt32,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr,System.UInt32,System.IntPtr,System.UInt32)"/>
              family of functions for that purpose instead.
            <br/>
            
            SHA-512 is vulnerable to length extension attacks;
              using it as a message authentication code (MAC) algorithm or keyed hash
              requires precautions. The
              <see cref="M:Monocypher.Monocypher.crypto_hmac_sha512(Monocypher.Monocypher.Byte64@,System.IntPtr,Monocypher.Monocypher.size_t,System.IntPtr,Monocypher.Monocypher.size_t)"/> family of
              functions provides HMAC with SHA-512. Use
              <see cref="M:Monocypher.Monocypher.crypto_verify64(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte64@)"/> to compare MACs
              created this way.
            <br/>
            
            </summary>
            <param name="hash">The output hash, which is always 64 bytes long.</param>
            <param name="message">The message to hash. May overlap with
                  <paramref name="hash"/>. May be
                  NULL if
                  <paramref name="message_size"/> is 0.</param>
            <param name="message_size">Length of <paramref name="message"/>, in bytes.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_sha512_update(Monocypher.Monocypher.crypto_sha512_ctx@,System.IntPtr,Monocypher.Monocypher.size_t)">
            <summary>
            
            SHA-512 is a cryptographically secure hash, provided to enable compatibility
              with other cryptographic systems. It is generally recommended to use
              <see cref="M:Monocypher.Monocypher.crypto_blake2b(Monocypher.Monocypher.Byte64@,System.IntPtr,Monocypher.Monocypher.size_t)"/> instead, as it both
              performs faster on x86_64 CPUs and lacks many of the pitfalls of SHA-512.
            <br/>
            
            Note that SHA-512 itself is not suitable for hashing passwords and deriving keys
              from them; use the <see cref="M:Monocypher.Monocypher.crypto_argon2i(System.IntPtr,System.UInt32,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr,System.UInt32,System.IntPtr,System.UInt32)"/>
              family of functions for that purpose instead.
            <br/>
            
            SHA-512 is vulnerable to length extension attacks;
              using it as a message authentication code (MAC) algorithm or keyed hash
              requires precautions. The
              <see cref="M:Monocypher.Monocypher.crypto_hmac_sha512(Monocypher.Monocypher.Byte64@,System.IntPtr,Monocypher.Monocypher.size_t,System.IntPtr,Monocypher.Monocypher.size_t)"/> family of
              functions provides HMAC with SHA-512. Use
              <see cref="M:Monocypher.Monocypher.crypto_verify64(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte64@)"/> to compare MACs
              created this way.
            <br/>
            
            </summary>
            <param name="message">The message to hash. May overlap with
                  <paramref name="hash"/>. May be
                  NULL if
                  <paramref name="message_size"/> is 0.</param>
            <param name="message_size">Length of <paramref name="message"/>, in bytes.</param>
            <param name="ctx">See Monocypher manual for more details.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_sha512_update(Monocypher.Monocypher.crypto_sha512_ctx@,System.ReadOnlySpan{System.Byte})">
            <summary>
            
            SHA-512 is a cryptographically secure hash, provided to enable compatibility
              with other cryptographic systems. It is generally recommended to use
              <see cref="M:Monocypher.Monocypher.crypto_blake2b(Monocypher.Monocypher.Byte64@,System.IntPtr,Monocypher.Monocypher.size_t)"/> instead, as it both
              performs faster on x86_64 CPUs and lacks many of the pitfalls of SHA-512.
            <br/>
            
            Note that SHA-512 itself is not suitable for hashing passwords and deriving keys
              from them; use the <see cref="M:Monocypher.Monocypher.crypto_argon2i(System.IntPtr,System.UInt32,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr,System.UInt32,System.IntPtr,System.UInt32)"/>
              family of functions for that purpose instead.
            <br/>
            
            SHA-512 is vulnerable to length extension attacks;
              using it as a message authentication code (MAC) algorithm or keyed hash
              requires precautions. The
              <see cref="M:Monocypher.Monocypher.crypto_hmac_sha512(Monocypher.Monocypher.Byte64@,System.IntPtr,Monocypher.Monocypher.size_t,System.IntPtr,Monocypher.Monocypher.size_t)"/> family of
              functions provides HMAC with SHA-512. Use
              <see cref="M:Monocypher.Monocypher.crypto_verify64(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte64@)"/> to compare MACs
              created this way.
            <br/>
            
            </summary>
            <param name="message">The message to hash. May overlap with
                  <paramref name="hash"/>. May be
                  NULL if
                  <paramref name="message_size"/> is 0.</param>
            <param name="ctx">See Monocypher manual for more details.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_sha512_final(Monocypher.Monocypher.crypto_sha512_ctx@,Monocypher.Monocypher.Byte64@)">
            <summary>
            
            SHA-512 is a cryptographically secure hash, provided to enable compatibility
              with other cryptographic systems. It is generally recommended to use
              <see cref="M:Monocypher.Monocypher.crypto_blake2b(Monocypher.Monocypher.Byte64@,System.IntPtr,Monocypher.Monocypher.size_t)"/> instead, as it both
              performs faster on x86_64 CPUs and lacks many of the pitfalls of SHA-512.
            <br/>
            
            Note that SHA-512 itself is not suitable for hashing passwords and deriving keys
              from them; use the <see cref="M:Monocypher.Monocypher.crypto_argon2i(System.IntPtr,System.UInt32,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr,System.UInt32,System.IntPtr,System.UInt32)"/>
              family of functions for that purpose instead.
            <br/>
            
            SHA-512 is vulnerable to length extension attacks;
              using it as a message authentication code (MAC) algorithm or keyed hash
              requires precautions. The
              <see cref="M:Monocypher.Monocypher.crypto_hmac_sha512(Monocypher.Monocypher.Byte64@,System.IntPtr,Monocypher.Monocypher.size_t,System.IntPtr,Monocypher.Monocypher.size_t)"/> family of
              functions provides HMAC with SHA-512. Use
              <see cref="M:Monocypher.Monocypher.crypto_verify64(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte64@)"/> to compare MACs
              created this way.
            <br/>
            
            </summary>
            <param name="hash">A 64-byte buffer. The output hash, which is always 64 bytes long.</param>
            <param name="ctx">See Monocypher manual for more details.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_sha512_final(Monocypher.Monocypher.crypto_sha512_ctx@,System.Span{System.Byte})">
            <summary>
            
            SHA-512 is a cryptographically secure hash, provided to enable compatibility
              with other cryptographic systems. It is generally recommended to use
              <see cref="M:Monocypher.Monocypher.crypto_blake2b(Monocypher.Monocypher.Byte64@,System.IntPtr,Monocypher.Monocypher.size_t)"/> instead, as it both
              performs faster on x86_64 CPUs and lacks many of the pitfalls of SHA-512.
            <br/>
            
            Note that SHA-512 itself is not suitable for hashing passwords and deriving keys
              from them; use the <see cref="M:Monocypher.Monocypher.crypto_argon2i(System.IntPtr,System.UInt32,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr,System.UInt32,System.IntPtr,System.UInt32)"/>
              family of functions for that purpose instead.
            <br/>
            
            SHA-512 is vulnerable to length extension attacks;
              using it as a message authentication code (MAC) algorithm or keyed hash
              requires precautions. The
              <see cref="M:Monocypher.Monocypher.crypto_hmac_sha512(Monocypher.Monocypher.Byte64@,System.IntPtr,Monocypher.Monocypher.size_t,System.IntPtr,Monocypher.Monocypher.size_t)"/> family of
              functions provides HMAC with SHA-512. Use
              <see cref="M:Monocypher.Monocypher.crypto_verify64(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte64@)"/> to compare MACs
              created this way.
            <br/>
            
            </summary>
            <param name="hash">A 64-byte buffer. The output hash, which is always 64 bytes long.</param>
            <param name="ctx">See Monocypher manual for more details.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_sha512(Monocypher.Monocypher.Byte64@,System.IntPtr,Monocypher.Monocypher.size_t)">
            <summary>
            
            SHA-512 is a cryptographically secure hash, provided to enable compatibility
              with other cryptographic systems. It is generally recommended to use
              <see cref="M:Monocypher.Monocypher.crypto_blake2b(Monocypher.Monocypher.Byte64@,System.IntPtr,Monocypher.Monocypher.size_t)"/> instead, as it both
              performs faster on x86_64 CPUs and lacks many of the pitfalls of SHA-512.
            <br/>
            
            Note that SHA-512 itself is not suitable for hashing passwords and deriving keys
              from them; use the <see cref="M:Monocypher.Monocypher.crypto_argon2i(System.IntPtr,System.UInt32,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr,System.UInt32,System.IntPtr,System.UInt32)"/>
              family of functions for that purpose instead.
            <br/>
            
            SHA-512 is vulnerable to length extension attacks;
              using it as a message authentication code (MAC) algorithm or keyed hash
              requires precautions. The
              <see cref="M:Monocypher.Monocypher.crypto_hmac_sha512(Monocypher.Monocypher.Byte64@,System.IntPtr,Monocypher.Monocypher.size_t,System.IntPtr,Monocypher.Monocypher.size_t)"/> family of
              functions provides HMAC with SHA-512. Use
              <see cref="M:Monocypher.Monocypher.crypto_verify64(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte64@)"/> to compare MACs
              created this way.
            <br/>
            
            </summary>
            <param name="hash">A 64-byte buffer. The output hash, which is always 64 bytes long.</param>
            <param name="message">The message to hash. May overlap with
                  <paramref name="hash"/>. May be
                  NULL if
                  <paramref name="message_size"/> is 0.</param>
            <param name="message_size">Length of <paramref name="message"/>, in bytes.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_sha512(System.Span{System.Byte},System.ReadOnlySpan{System.Byte})">
            <summary>
            
            SHA-512 is a cryptographically secure hash, provided to enable compatibility
              with other cryptographic systems. It is generally recommended to use
              <see cref="M:Monocypher.Monocypher.crypto_blake2b(Monocypher.Monocypher.Byte64@,System.IntPtr,Monocypher.Monocypher.size_t)"/> instead, as it both
              performs faster on x86_64 CPUs and lacks many of the pitfalls of SHA-512.
            <br/>
            
            Note that SHA-512 itself is not suitable for hashing passwords and deriving keys
              from them; use the <see cref="M:Monocypher.Monocypher.crypto_argon2i(System.IntPtr,System.UInt32,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr,System.UInt32,System.IntPtr,System.UInt32)"/>
              family of functions for that purpose instead.
            <br/>
            
            SHA-512 is vulnerable to length extension attacks;
              using it as a message authentication code (MAC) algorithm or keyed hash
              requires precautions. The
              <see cref="M:Monocypher.Monocypher.crypto_hmac_sha512(Monocypher.Monocypher.Byte64@,System.IntPtr,Monocypher.Monocypher.size_t,System.IntPtr,Monocypher.Monocypher.size_t)"/> family of
              functions provides HMAC with SHA-512. Use
              <see cref="M:Monocypher.Monocypher.crypto_verify64(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte64@)"/> to compare MACs
              created this way.
            <br/>
            
            </summary>
            <param name="hash">A 64-byte buffer. The output hash, which is always 64 bytes long.</param>
            <param name="message">The message to hash. May overlap with
                  <paramref name="hash"/>. May be
                  NULL if
                  <paramref name="message_size"/> is 0.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_hmac_sha512_init(Monocypher.Monocypher.crypto_hmac_sha512_ctx@,System.IntPtr,Monocypher.Monocypher.size_t)">
            <summary>
            
            HMAC with SHA-512 is a cryptographically secure message authentication code
              (MAC), provided to enable compatibility with other cryptographic systems. It
              is generally recommended to use
              <see cref="M:Monocypher.Monocypher.crypto_blake2b_general(System.IntPtr,Monocypher.Monocypher.size_t,System.IntPtr,Monocypher.Monocypher.size_t,System.IntPtr,Monocypher.Monocypher.size_t)"/> instead, as
              it performs faster on x86_64 CPUs.
            <br/>
            
            </summary>
            <param name="key">Some secret key. One cannot predict the final hash without it. Users may
                  want to wipe the key with
                  <see cref="M:Monocypher.Monocypher.crypto_wipe(System.IntPtr,Monocypher.Monocypher.size_t)"/> once they are done
                  with it.</param>
            <param name="key_size">Length of <paramref name="key"/>, in bytes. 32 is a good
                  default. Keys longer than 128 bytes will be reduced to 64 bytes by hashing
                  the key with SHA-512.</param>
            <param name="ctx">See Monocypher manual for more details.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_hmac_sha512_init(Monocypher.Monocypher.crypto_hmac_sha512_ctx@,System.ReadOnlySpan{System.Byte})">
            <summary>
            
            HMAC with SHA-512 is a cryptographically secure message authentication code
              (MAC), provided to enable compatibility with other cryptographic systems. It
              is generally recommended to use
              <see cref="M:Monocypher.Monocypher.crypto_blake2b_general(System.IntPtr,Monocypher.Monocypher.size_t,System.IntPtr,Monocypher.Monocypher.size_t,System.IntPtr,Monocypher.Monocypher.size_t)"/> instead, as
              it performs faster on x86_64 CPUs.
            <br/>
            
            </summary>
            <param name="key">Some secret key. One cannot predict the final hash without it. Users may
                  want to wipe the key with
                  <see cref="M:Monocypher.Monocypher.crypto_wipe(System.IntPtr,Monocypher.Monocypher.size_t)"/> once they are done
                  with it.</param>
            <param name="ctx">See Monocypher manual for more details.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_hmac_sha512_update(Monocypher.Monocypher.crypto_hmac_sha512_ctx@,System.IntPtr,Monocypher.Monocypher.size_t)">
            <summary>
            
            HMAC with SHA-512 is a cryptographically secure message authentication code
              (MAC), provided to enable compatibility with other cryptographic systems. It
              is generally recommended to use
              <see cref="M:Monocypher.Monocypher.crypto_blake2b_general(System.IntPtr,Monocypher.Monocypher.size_t,System.IntPtr,Monocypher.Monocypher.size_t,System.IntPtr,Monocypher.Monocypher.size_t)"/> instead, as
              it performs faster on x86_64 CPUs.
            <br/>
            
            </summary>
            <param name="message">The message to compute the HMAC for. May overlap with
                  <paramref name="hmac"/>. May be
                  NULL if
                  <paramref name="message_size"/> is 0.</param>
            <param name="message_size">Length of <paramref name="message"/>, in bytes.</param>
            <param name="ctx">See Monocypher manual for more details.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_hmac_sha512_update(Monocypher.Monocypher.crypto_hmac_sha512_ctx@,System.ReadOnlySpan{System.Byte})">
            <summary>
            
            HMAC with SHA-512 is a cryptographically secure message authentication code
              (MAC), provided to enable compatibility with other cryptographic systems. It
              is generally recommended to use
              <see cref="M:Monocypher.Monocypher.crypto_blake2b_general(System.IntPtr,Monocypher.Monocypher.size_t,System.IntPtr,Monocypher.Monocypher.size_t,System.IntPtr,Monocypher.Monocypher.size_t)"/> instead, as
              it performs faster on x86_64 CPUs.
            <br/>
            
            </summary>
            <param name="message">The message to compute the HMAC for. May overlap with
                  <paramref name="hmac"/>. May be
                  NULL if
                  <paramref name="message_size"/> is 0.</param>
            <param name="ctx">See Monocypher manual for more details.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_hmac_sha512_final(Monocypher.Monocypher.crypto_hmac_sha512_ctx@,Monocypher.Monocypher.Byte64@)">
            <summary>
            
            HMAC with SHA-512 is a cryptographically secure message authentication code
              (MAC), provided to enable compatibility with other cryptographic systems. It
              is generally recommended to use
              <see cref="M:Monocypher.Monocypher.crypto_blake2b_general(System.IntPtr,Monocypher.Monocypher.size_t,System.IntPtr,Monocypher.Monocypher.size_t,System.IntPtr,Monocypher.Monocypher.size_t)"/> instead, as
              it performs faster on x86_64 CPUs.
            <br/>
            
            </summary>
            <param name="hmac">A 64-byte buffer. The output MAC, which is always 64 bytes long.</param>
            <param name="ctx">See Monocypher manual for more details.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_hmac_sha512_final(Monocypher.Monocypher.crypto_hmac_sha512_ctx@,System.Span{System.Byte})">
            <summary>
            
            HMAC with SHA-512 is a cryptographically secure message authentication code
              (MAC), provided to enable compatibility with other cryptographic systems. It
              is generally recommended to use
              <see cref="M:Monocypher.Monocypher.crypto_blake2b_general(System.IntPtr,Monocypher.Monocypher.size_t,System.IntPtr,Monocypher.Monocypher.size_t,System.IntPtr,Monocypher.Monocypher.size_t)"/> instead, as
              it performs faster on x86_64 CPUs.
            <br/>
            
            </summary>
            <param name="hmac">A 64-byte buffer. The output MAC, which is always 64 bytes long.</param>
            <param name="ctx">See Monocypher manual for more details.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_hmac_sha512(Monocypher.Monocypher.Byte64@,System.IntPtr,Monocypher.Monocypher.size_t,System.IntPtr,Monocypher.Monocypher.size_t)">
            <summary>
            
            HMAC with SHA-512 is a cryptographically secure message authentication code
              (MAC), provided to enable compatibility with other cryptographic systems. It
              is generally recommended to use
              <see cref="M:Monocypher.Monocypher.crypto_blake2b_general(System.IntPtr,Monocypher.Monocypher.size_t,System.IntPtr,Monocypher.Monocypher.size_t,System.IntPtr,Monocypher.Monocypher.size_t)"/> instead, as
              it performs faster on x86_64 CPUs.
            <br/>
            
            </summary>
            <param name="hmac">A 64-byte buffer. The output MAC, which is always 64 bytes long.</param>
            <param name="key">Some secret key. One cannot predict the final hash without it. Users may
                  want to wipe the key with
                  <see cref="M:Monocypher.Monocypher.crypto_wipe(System.IntPtr,Monocypher.Monocypher.size_t)"/> once they are done
                  with it.</param>
            <param name="key_size">Length of <paramref name="key"/>, in bytes. 32 is a good
                  default. Keys longer than 128 bytes will be reduced to 64 bytes by hashing
                  the key with SHA-512.</param>
            <param name="message">The message to compute the HMAC for. May overlap with
                  <paramref name="hmac"/>. May be
                  NULL if
                  <paramref name="message_size"/> is 0.</param>
            <param name="message_size">Length of <paramref name="message"/>, in bytes.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_hmac_sha512(System.Span{System.Byte},System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte})">
            <summary>
            
            HMAC with SHA-512 is a cryptographically secure message authentication code
              (MAC), provided to enable compatibility with other cryptographic systems. It
              is generally recommended to use
              <see cref="M:Monocypher.Monocypher.crypto_blake2b_general(System.IntPtr,Monocypher.Monocypher.size_t,System.IntPtr,Monocypher.Monocypher.size_t,System.IntPtr,Monocypher.Monocypher.size_t)"/> instead, as
              it performs faster on x86_64 CPUs.
            <br/>
            
            </summary>
            <param name="hmac">A 64-byte buffer. The output MAC, which is always 64 bytes long.</param>
            <param name="key">Some secret key. One cannot predict the final hash without it. Users may
                  want to wipe the key with
                  <see cref="M:Monocypher.Monocypher.crypto_wipe(System.IntPtr,Monocypher.Monocypher.size_t)"/> once they are done
                  with it.</param>
            <param name="message">The message to compute the HMAC for. May overlap with
                  <paramref name="hmac"/>. May be
                  NULL if
                  <paramref name="message_size"/> is 0.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_ed25519_public_key(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)">
            <summary>
            
            The <see cref="M:Monocypher.Monocypher.crypto_ed25519_sign(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,System.IntPtr,Monocypher.Monocypher.size_t)"/>() and
              <see cref="M:Monocypher.Monocypher.crypto_ed25519_check(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte32@,System.IntPtr,Monocypher.Monocypher.size_t)"/>() functions provide
              Ed25519 public key signatures and verification with SHA-512 as the underlying
              hash function; they are interoperable with other Ed25519 implementations. If
              you have no interoperability requirements, prefer
              <see cref="M:Monocypher.Monocypher.crypto_sign(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,System.IntPtr,Monocypher.Monocypher.size_t)"/>.
            <br/>
            
            </summary>
            <param name="public_key">A 32-byte buffer. See Monocypher manual for more details.</param>
            <param name="secret_key">A 32-byte buffer. See Monocypher manual for more details.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_ed25519_public_key(System.Span{System.Byte},System.ReadOnlySpan{System.Byte})">
            <summary>
            
            The <see cref="M:Monocypher.Monocypher.crypto_ed25519_sign(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,System.IntPtr,Monocypher.Monocypher.size_t)"/>() and
              <see cref="M:Monocypher.Monocypher.crypto_ed25519_check(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte32@,System.IntPtr,Monocypher.Monocypher.size_t)"/>() functions provide
              Ed25519 public key signatures and verification with SHA-512 as the underlying
              hash function; they are interoperable with other Ed25519 implementations. If
              you have no interoperability requirements, prefer
              <see cref="M:Monocypher.Monocypher.crypto_sign(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,System.IntPtr,Monocypher.Monocypher.size_t)"/>.
            <br/>
            
            </summary>
            <param name="public_key">A 32-byte buffer. See Monocypher manual for more details.</param>
            <param name="secret_key">A 32-byte buffer. See Monocypher manual for more details.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_ed25519_sign(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,System.IntPtr,Monocypher.Monocypher.size_t)">
            <summary>
            
            The <see cref="M:Monocypher.Monocypher.crypto_ed25519_sign(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,System.IntPtr,Monocypher.Monocypher.size_t)"/>() and
              <see cref="M:Monocypher.Monocypher.crypto_ed25519_check(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte32@,System.IntPtr,Monocypher.Monocypher.size_t)"/>() functions provide
              Ed25519 public key signatures and verification with SHA-512 as the underlying
              hash function; they are interoperable with other Ed25519 implementations. If
              you have no interoperability requirements, prefer
              <see cref="M:Monocypher.Monocypher.crypto_sign(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,System.IntPtr,Monocypher.Monocypher.size_t)"/>.
            <br/>
            
            </summary>
            <param name="signature">A 64-byte buffer. See Monocypher manual for more details.</param>
            <param name="secret_key">A 32-byte buffer. See Monocypher manual for more details.</param>
            <param name="public_key">A 32-byte buffer. See Monocypher manual for more details.</param>
            <param name="message">See Monocypher manual for more details.</param>
            <param name="message_size">See Monocypher manual for more details.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_ed25519_sign(System.Span{System.Byte},System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte})">
            <summary>
            
            The <see cref="M:Monocypher.Monocypher.crypto_ed25519_sign(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,System.IntPtr,Monocypher.Monocypher.size_t)"/>() and
              <see cref="M:Monocypher.Monocypher.crypto_ed25519_check(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte32@,System.IntPtr,Monocypher.Monocypher.size_t)"/>() functions provide
              Ed25519 public key signatures and verification with SHA-512 as the underlying
              hash function; they are interoperable with other Ed25519 implementations. If
              you have no interoperability requirements, prefer
              <see cref="M:Monocypher.Monocypher.crypto_sign(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,System.IntPtr,Monocypher.Monocypher.size_t)"/>.
            <br/>
            
            </summary>
            <param name="signature">A 64-byte buffer. See Monocypher manual for more details.</param>
            <param name="secret_key">A 32-byte buffer. See Monocypher manual for more details.</param>
            <param name="public_key">A 32-byte buffer. See Monocypher manual for more details.</param>
            <param name="message">See Monocypher manual for more details.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_ed25519_check(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte32@,System.IntPtr,Monocypher.Monocypher.size_t)">
            <summary>
            
            The <see cref="M:Monocypher.Monocypher.crypto_ed25519_sign(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,System.IntPtr,Monocypher.Monocypher.size_t)"/>() and
              <see cref="M:Monocypher.Monocypher.crypto_ed25519_check(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte32@,System.IntPtr,Monocypher.Monocypher.size_t)"/>() functions provide
              Ed25519 public key signatures and verification with SHA-512 as the underlying
              hash function; they are interoperable with other Ed25519 implementations. If
              you have no interoperability requirements, prefer
              <see cref="M:Monocypher.Monocypher.crypto_sign(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,System.IntPtr,Monocypher.Monocypher.size_t)"/>.
            <br/>
            
            </summary>
            <param name="signature">A 64-byte buffer. See Monocypher manual for more details.</param>
            <param name="public_key">A 32-byte buffer. See Monocypher manual for more details.</param>
            <param name="message">See Monocypher manual for more details.</param>
            <param name="message_size">See Monocypher manual for more details.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_ed25519_check(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte})">
            <summary>
            
            The <see cref="M:Monocypher.Monocypher.crypto_ed25519_sign(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,System.IntPtr,Monocypher.Monocypher.size_t)"/>() and
              <see cref="M:Monocypher.Monocypher.crypto_ed25519_check(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte32@,System.IntPtr,Monocypher.Monocypher.size_t)"/>() functions provide
              Ed25519 public key signatures and verification with SHA-512 as the underlying
              hash function; they are interoperable with other Ed25519 implementations. If
              you have no interoperability requirements, prefer
              <see cref="M:Monocypher.Monocypher.crypto_sign(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,System.IntPtr,Monocypher.Monocypher.size_t)"/>.
            <br/>
            
            </summary>
            <param name="signature">A 64-byte buffer. See Monocypher manual for more details.</param>
            <param name="public_key">A 32-byte buffer. See Monocypher manual for more details.</param>
            <param name="message">See Monocypher manual for more details.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_ed25519_sign_init_first_pass(Monocypher.Monocypher.crypto_sign_ctx_abstract@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)">
            <summary>
            
            These functions are variants of
              <see cref="M:Monocypher.Monocypher.crypto_ed25519_sign(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,System.IntPtr,Monocypher.Monocypher.size_t)"/> and
              <see cref="M:Monocypher.Monocypher.crypto_ed25519_check(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte32@,System.IntPtr,Monocypher.Monocypher.size_t)"/>. Prefer those
              simpler functions if possible.
            <br/>
            
            These functions provide Ed25519 public key signatures and verification with
              SHA-512 as the underlying hash function; they are interoperable with other
              Ed25519 implementations. If you have no interoperability requirements, prefer
              <see cref="M:Monocypher.Monocypher.crypto_sign(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,System.IntPtr,Monocypher.Monocypher.size_t)"/>.
            <br/>
            
            </summary>
            <param name="ctx">See Monocypher manual for more details.</param>
            <param name="secret_key">A 32-byte buffer. See Monocypher manual for more details.</param>
            <param name="public_key">A 32-byte buffer. See Monocypher manual for more details.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_ed25519_sign_init_first_pass(Monocypher.Monocypher.crypto_sign_ctx_abstract@,System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte})">
            <summary>
            
            These functions are variants of
              <see cref="M:Monocypher.Monocypher.crypto_ed25519_sign(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,System.IntPtr,Monocypher.Monocypher.size_t)"/> and
              <see cref="M:Monocypher.Monocypher.crypto_ed25519_check(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte32@,System.IntPtr,Monocypher.Monocypher.size_t)"/>. Prefer those
              simpler functions if possible.
            <br/>
            
            These functions provide Ed25519 public key signatures and verification with
              SHA-512 as the underlying hash function; they are interoperable with other
              Ed25519 implementations. If you have no interoperability requirements, prefer
              <see cref="M:Monocypher.Monocypher.crypto_sign(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,System.IntPtr,Monocypher.Monocypher.size_t)"/>.
            <br/>
            
            </summary>
            <param name="ctx">See Monocypher manual for more details.</param>
            <param name="secret_key">A 32-byte buffer. See Monocypher manual for more details.</param>
            <param name="public_key">A 32-byte buffer. See Monocypher manual for more details.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_ed25519_check_init(Monocypher.Monocypher.crypto_check_ctx_abstract@,Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte32@)">
            <summary>
            
            These functions are variants of
              <see cref="M:Monocypher.Monocypher.crypto_ed25519_sign(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,System.IntPtr,Monocypher.Monocypher.size_t)"/> and
              <see cref="M:Monocypher.Monocypher.crypto_ed25519_check(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte32@,System.IntPtr,Monocypher.Monocypher.size_t)"/>. Prefer those
              simpler functions if possible.
            <br/>
            
            These functions provide Ed25519 public key signatures and verification with
              SHA-512 as the underlying hash function; they are interoperable with other
              Ed25519 implementations. If you have no interoperability requirements, prefer
              <see cref="M:Monocypher.Monocypher.crypto_sign(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,System.IntPtr,Monocypher.Monocypher.size_t)"/>.
            <br/>
            
            </summary>
            <param name="ctx">See Monocypher manual for more details.</param>
            <param name="signature">A 64-byte buffer. See Monocypher manual for more details.</param>
            <param name="public_key">A 32-byte buffer. See Monocypher manual for more details.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_ed25519_check_init(Monocypher.Monocypher.crypto_check_ctx_abstract@,System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte})">
            <summary>
            
            These functions are variants of
              <see cref="M:Monocypher.Monocypher.crypto_ed25519_sign(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,System.IntPtr,Monocypher.Monocypher.size_t)"/> and
              <see cref="M:Monocypher.Monocypher.crypto_ed25519_check(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte32@,System.IntPtr,Monocypher.Monocypher.size_t)"/>. Prefer those
              simpler functions if possible.
            <br/>
            
            These functions provide Ed25519 public key signatures and verification with
              SHA-512 as the underlying hash function; they are interoperable with other
              Ed25519 implementations. If you have no interoperability requirements, prefer
              <see cref="M:Monocypher.Monocypher.crypto_sign(Monocypher.Monocypher.Byte64@,Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@,System.IntPtr,Monocypher.Monocypher.size_t)"/>.
            <br/>
            
            </summary>
            <param name="ctx">See Monocypher manual for more details.</param>
            <param name="signature">A 64-byte buffer. See Monocypher manual for more details.</param>
            <param name="public_key">A 32-byte buffer. See Monocypher manual for more details.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_from_ed25519_private(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)">
            <summary>
            
            These functions work like
              <see cref="M:Monocypher.Monocypher.crypto_from_eddsa_private(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/> and
              <see cref="M:Monocypher.Monocypher.crypto_from_eddsa_public(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>, except
              that they operate on Ed25519 key pairs rather than key pairs for EdDSA with
              BLAKE2b. Please see the documentation for those functions for details.
            
            </summary>
            <param name="x25519">A 32-byte buffer. See Monocypher manual for more details.</param>
            <param name="eddsa">A 32-byte buffer. See Monocypher manual for more details.</param>
        </member>
        <member name="M:Monocypher.Monocypher.crypto_from_ed25519_private(System.Span{System.Byte},System.ReadOnlySpan{System.Byte})">
            <summary>
            
            These functions work like
              <see cref="M:Monocypher.Monocypher.crypto_from_eddsa_private(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/> and
              <see cref="M:Monocypher.Monocypher.crypto_from_eddsa_public(Monocypher.Monocypher.Byte32@,Monocypher.Monocypher.Byte32@)"/>, except
              that they operate on Ed25519 key pairs rather than key pairs for EdDSA with
              BLAKE2b. Please see the documentation for those functions for details.
            
            </summary>
            <param name="x25519">A 32-byte buffer. See Monocypher manual for more details.</param>
            <param name="eddsa">A 32-byte buffer. See Monocypher manual for more details.</param>
        </member>
    </members>
</doc>
